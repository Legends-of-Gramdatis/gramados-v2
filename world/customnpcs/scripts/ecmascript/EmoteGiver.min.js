



var API = Java.type('noppes.npcs.api.NpcAPI').Instance();
var INbt = Java.type('noppes.npcs.api.INbt');
var LogManager = Java.type('org.apache.logging.log4j.LogManager');
var Logger = LogManager.getLogger(typeof CONFIG_SERVER != typeof undefined ? CONFIG_SERVER.NAME : "");
var ForgeLoader = Java.type('net.minecraftforge.fml.common.Loader').instance();
var EntityType = Java.type('noppes.npcs.api.constants.EntityType');

var NbtTypes = {
    "Byte": 1,
    "Short": 2,
    "Integer": 3,
    "Long": 4,
    "Float": 5,
    "Double": 6,
    "ByteArray": 7,
    "String": 8,
    "List": 9,
    "Compound": 10,
    "IntegerArray": 11,
};

function getNbtType(num) {
    for(var n in NbtTypes) {
var nbtType = NbtTypes[n];
        if(nbtType === num) { return n; }
    }
    return null;
}

function getMCModList() {
    var modlist = [];
    var loadmods = Java.type("net.minecraftforge.fml.common.Loader").instance().getModList();

    for(var mid in loadmods) {
var lmod = loadmods[mid];
        modlist.push(lmod.getModId());
    }

    return modlist;
}

function hasMCMod(name) {
    return getMCModList().indexOf(name) > -1;
}


function executeCommand(player, command, as_player) {
	if(typeof(as_player) == typeof(undefined) || as_player === null) { as_player = null; }
	if(as_player == null) { as_player = player.getName(); }
	var cmd = API.createNPC(player.world.getMCWorld());

	return cmd.executeCommand("/execute "+as_player+" ~ ~ ~ "+command);

}

function executeCommandGlobal(command, dim) {
	if(typeof(dim) == typeof(undefined) || dim === null) { dim = 0; }
	return API.createNPC(API.getIWorld(dim).getMCWorld()).executeCommand(command);
}

function array_shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}

function array_filter(a, fn) {
    var aa = [];
    for (var i in a) {
        if (fn(a[i])) { aa.push(a[i]); }
    }

    return aa;
}

function array_dist(a) {
    var b = [];
    for (var c in a) {
        if (b.indexOf(a[c]) == -1) {
            b.push(a[c]);
        }
    }

    return b;
}

function array_remove(array, element) {
    var index = array.indexOf(element);
    if (index !== -1) {
        array.splice(index, 1);
    }
}

function removeFromArray(arr, vals) {
    if (typeof(vals) == 'string') { vals = [vals]; }
    var a = arr;
    for(var v in vals) {
var val = vals[v];
        array_remove(a, val);
    }
    return a;
}

function removeFromArrayByKey(arr, keys) {
    var narr = [];
    for(var k in keys) {
var key = keys[k];
        keys[k] = parseInt(key);
    }
    for(var i in arr) {
var ari = arr[i];
        if (keys.indexOf(i) > -1) {
            narr.push(ari);
        }
    }
    return narr;
}


function array_merge(a1, a2) {
    var bb = [];
    for (var k in a1) {
        bb[k] = a1[k];
    }
    for (var k in a2) {
        bb[k] = a2[k];
    }
    return bb;
}

function arrayTransform(arr, elfn) {
    var newa = [];
    for(var a in arr) {
var arri = arr[a];
        newa.push(elfn(arri, a, arr));
    }
    return newa;
}

function arrayTakeRange(arr, start, end) {
	if(typeof(end) == typeof(undefined) || end === null) { end = null; }
    if (end == null) { end = arr.length; }
    var a = [];
    var _end = Math.min(end, arr.length);
    var _start = Math.min(start, _end);
    for (var i = _start; i < Math.min(end, arr.length); i++) {
        if (typeof(arr[i]) != typeof(undefined)) {
            a.push(arr[i]);
        }
    }
    return a;
}

function arrayOccurs(string, subArray, allowOverlapping, caseSensitive) {
	if(typeof(allowOverlapping) == typeof(undefined) || allowOverlapping === null) { allowOverlapping = false; }
	if(typeof(caseSensitive) == typeof(undefined) || caseSensitive === null) { caseSensitive = true; }
    var occ = 0;
    for(var i in subArray) {
var sel = subArray[i];
        occ += occurrences(string, sel, allowOverlapping, caseSensitive);
    }

    return occ;
}

function arrayFormat(array, format, sep) {
    var joined = "";
    for (var i = 0; i < array.length; i++) {
        joined += format.fill({
            "VALUE": array[i]
        }) + (i == array.length - 1 ? "" : sep || " ");
    }
    return joined;
}
var UNI = [
	'0',
	'1',
	'2',
	'3',
	'4',
	'5',
	'6',
	'7',
	'8',
	'9',
	'a',
	'b',
	'c',
	'd',
	'e',
	'f',
];
var CHAT_EMOTES = {
	"check_mark": "\u9366",
	"hp": "\u9390",
	"hphalf": "\u9391",
	"hpempty": "\u938E",
	"cross_mark": "\u9367",
	"sun": "\u2739",
	"star": "\u2729",
	"recycle": "\u267B",
	"seagull": "\u932A",
	//emoji
	"cool": "\u9914",
	"shocked": "\u9915",
	"smile": "\u9916",
	"joy": "\u9917",
	"wink": "\u9918",
	"happy": "\u9919",
	"crazy": "\u991A",
	//Misc
	"wifi5": "\u936A",
	"wifi4": "\u936B",
	"wifi3": "\u936C",
	"wifi2": "\u936D",
	"wifi1": "\u936E",
	"wifi0": "\u936F",
	"lang": "\u935C",
	"money": "\u932B",
	"trin": "\u932D",
	"unu": "\u932E",
	"folder": "\u932F",
	"thumbsup": "\u93F3",
	"thumbsdown": "\u93F4",
	"bomb": "\u93F5",
	"hazard": "\u93F6",
	"ying": "\u93F7",
	"danger": "\u93F8",
	"noperm": "\u93F9",
	"gear": "\u93FA",
	"stats": "\u93FB",
	"medal_bronze": "\u99F0",
	"medal_silver": "\u99F1",
	"medal_gold": "\u99F2",
	"medal_diamond": "\u99F3",
	"medal_emerald": "\u99F4",
	"unlock": "\u937E",
	"lock": "\u937F",
	//Arrows
	"arrow_u": "\u9920",
	"arrow_ur": "\u9921",
	"arrow_r": "\u9922",
	"arrow_dr": "\u9923",
	"arrow_d": "\u9924",
	"arrow_dl": "\u9925",
	"arrow_l": "\u9926",
	"arrow_ul": "\u9927",
	//Mobs
	"creeper": "\u92C0",
	"ccreeper": "\u92C1",
	"skeleton": "\u92C2",
	"wskeleton": "\u92C3",
	"spider": "\u92C4",
	"zombie": "\u92C5",
	"vzombie": "\u92C6",
	"slime": "\u92C7",
	"ghast": "\u92C8",
	"oghast": "\u92C9",
	"pigzombie": "\u92CA",
	"enderman": "\u92CB",
	"blaze": "\u92CE",
	"mslime": "\u92CF",
	"illager": "\u92D1",
	"pig": "\u92D3",
	"sheep": "\u92D4",
	"cow": "\u92D5",
	"chicken": "\u92D6",
	"villager": "\u92E5",

	//items
	"iron_ingot": "\u90B0",
	"gold_ingot": "\u90B1",
	"brick": "\u90B2",
	"nether_brick": "\u90B3",
	"coal": "\u90B4",
	"ccoal": "\u90B5",
	"diamond": "\u90B6",
	"ruby": "\u90B7",
	"emerald": "\u90B8",
	"nether_star": "\u90BD",

	//blocks items
	"coal_ore": "\u9220",
	"iron_ore": "\u9221",
	"gold_ore": "\u9222",
	"redstone_ore": "\u9223",
	"diamond_ore": "\u9224",
	"lapis_ore": "\u9225",
	"emerald_ore": "\u9226",
	"cobble": "\u9227",
	"mosscobble": "\u9228",
	"stone": "\u9229",
	"chest": "\u92F9",
	"enderchest": "\u92FB",
	"giftchest": "\u92FC",
	"pumpkin": "\u9270",
	"jacklantern": "\u9271",
	"melon": "\u9274",
	"cactus": "\u9276",
	"sponge": "\u927C",
	"tnt": "\u927E",
	"lit": "\u9200",
	"water": "\u920B",
	"lava": "\u920E",
	"portal": "\u920F",


	//Foods
	"creamcookie": "\u932C",
	"cookie": "\u90EB",
	"cake": "\u90EC",
	"ppie": "\u90ED",

	//Weapons and tools
	"wooden_sword": "\u9000",
	"wooden_pickaxe": "\u9001",
	"wooden_shovel": "\u9002",
	"wooden_axe": "\u9003",
	"wooden_hoe": "\u9004",

	"stone_sword": "\u9005",
	"stone_pickaxe": "\u9006",
	"stone_shovel": "\u9007",
	"stone_axe": "\u9008",
	"stone_hoe": "\u9009",

	"golden_sword": "\u900A",
	"golden_pickaxe": "\u900B",
	"golden_shovel": "\u900C",
	"golden_axe": "\u900D",
	"golden_hoe": "\u900E",

	"iron_sword": "\u9010",
	"iron_pickaxe": "\u9011",
	"iron_shovel": "\u9012",
	"iron_axe": "\u9013",
	"iron_hoe": "\u9014",

	"diamond_sword": "\u9015",
	"diamond_pickaxe": "\u9016",
	"diamond_shovel": "\u9017",
	"diamond_axe": "\u9018",
	"diamond_hoe": "\u9019",


	//Emotes that *should not be* public
	"box": "\u2B1B",

};
//config for gramados

//Configure your own currency units
//Units of currency, with own names, with lowest unit being 1
var _COINTABLE = { //MUST BE FROM LOW TO HIGH
    'c': 1,
    'g': 100,
    'k': 100000,
    'm': 100000000,
    'b': 100000000000,
    't': 100000000000000,
    'q': 100000000000000000,
    's': 100000000000000000000
}; //With this setup, the syntax for 223503 would be 2k235g3c (case-INSensitive)

//Extra currencies that have no items themselves
var VIRTUAL_CURRENCIES = [{
        "name": "amoney",
        "displayName": "Arcade Tokens",
        "default": 0,
        "prefix": "&b:money:A",
        "suffix": "",
    },
    {
        "name": "vmoney",
        "displayName": "Vote Tokens",
        "default": 0,
        "prefix": "&d:money:V",
        "suffix": "",
    },
];


//Currency settings
var _COINITEMNAME = '&2&lMoney&r'; //Custom name of currency
var _COINITEM_PREFIX = '&e'; //Prefix showing before money value lore (used for color coding)

//Your money items, and their values in money syntax
//"value": "item_id",
var LOWVALUE_ID = "variedcommodities:coin_iron";
var MIDVALUE_ID = "variedcommodities:money";
var HIGHVALUE_ID = "variedcommodities:plans";
var ULTRAVALUE_ID = "variedcommodities:satchel";


//Coin Items for the physical currency
var _COINITEMS = { //MUST BE FROM LOW TO HIGH
    '1c': LOWVALUE_ID,
    '5c': LOWVALUE_ID,
    '10c': LOWVALUE_ID,
    '20c': LOWVALUE_ID,
    '50c': LOWVALUE_ID,
    '1g': LOWVALUE_ID,
    '2g': LOWVALUE_ID,
    '5g': MIDVALUE_ID,
    '10g': MIDVALUE_ID,
    '20g': MIDVALUE_ID,
    '50g': MIDVALUE_ID,
    '100g': MIDVALUE_ID,
    '200g': MIDVALUE_ID,
    '500g': MIDVALUE_ID,
    '1k': HIGHVALUE_ID,
    '2k': HIGHVALUE_ID,
    '10k': HIGHVALUE_ID,
    '20k': HIGHVALUE_ID,
    '50k': HIGHVALUE_ID,
    '100k': HIGHVALUE_ID,
    '1m': ULTRAVALUE_ID,
    '2m': ULTRAVALUE_ID,
    '5m': ULTRAVALUE_ID,
    '10m': ULTRAVALUE_ID,
    '20m': ULTRAVALUE_ID,
    '50m': ULTRAVALUE_ID,
    '100m': ULTRAVALUE_ID,
    '200m': ULTRAVALUE_ID,
    '500m': ULTRAVALUE_ID,
    '1b': ULTRAVALUE_ID,
    '2b': ULTRAVALUE_ID,
    '5b': ULTRAVALUE_ID,
    '10b': ULTRAVALUE_ID,
    '20b': ULTRAVALUE_ID,
    '50b': ULTRAVALUE_ID,
    '100b': ULTRAVALUE_ID,
    '200b': ULTRAVALUE_ID,
    '500b': ULTRAVALUE_ID,
    '1t': ULTRAVALUE_ID,
    '2t': ULTRAVALUE_ID,
    '5t': ULTRAVALUE_ID,
    '10t': ULTRAVALUE_ID,
    '20t': ULTRAVALUE_ID,
    '50t': ULTRAVALUE_ID,
    '100t': ULTRAVALUE_ID,
    '200t': ULTRAVALUE_ID,
    '500t': ULTRAVALUE_ID,
    '1q': ULTRAVALUE_ID,
};//LANGUAGE settings
var _MSG = {
    //Error Strings
	"cmdNotFound": "&cCould not find this command!",
	"cmdNoPerm": "&cYou don't have permission to this command!",
	"argNotValid": "&c'{argName}' is not a valid id/name! It can only contain: &o{allowed}",
	"argToShort": "&c'{argName}' is too short! (Min. {allowed} characters)",
	"argNoColor": "&c'{argName}' cannot contain colorcoding!",
	"argEnum": "&c'{argName}' must be one of the following: &o{allowed}!",
	"argNaN": "&c'{argName}' is not a number!",
	"argMax": "&c'{argName}' cannot be bigger than {allowed}!",
	"argMin": "&c'{argName}' cannot be smaller than {allowed}!",
	"argNotExists": "&c{type} '{argVal}' does not exists!",
	"argExists": "&c{type} '{argVal}' already exists!",
	"argColor": "&cColors must be one of the following: {allowed}!",
	"argColorEffect": "&cChat effects must be one of the following: {allowed}!",
	"argItemAttr": "&cItem attributes must be one of these {allowed}!",
	"argBool": "&c{dataType} must be true or false!",
	//button texts
    "undoBtnText": "Undo",
    "refreshBtnText": "Refresh"
};
//===== CONFIG
var CONFIG_SERVER = {
    "NAME": "TestServer",
    "TITLE": "&5&lTestServer",
    "PREFIX": "&5&l",
    "BAR_OPEN": "&r&l[=======] &r",
    "BAR_CLOSE": "&r&l [=======]&r",
    "DEFAULT_PERM_TEAMS": [
        "Owner",
        "Developer"
    ],
    "DEFAULT_PERM_PLAYERS": [],
    "DEFAULT_TEAM_JOIN": "Player",
    "DEVELOPMENT_MODE": false,
    "USE_DISK": "DEFAULT",
    "LICENSE_KEY": "",
    "FILE_DISKS": {
        "DEFAULT": {
            "path": "{worldname}/customnpcs/scripts/world_data.json"
        },
        "CST_DATA": {
            "path": "CustomServerTools/data/data.json"
        }
    },
    "MONEY_POUCH_SCRIPT": null,
    "REGION_TYPES": {
        "garden": {
            "build": [],
            "interact": []
        }
    }
};

var DEFAULT_MONEY = 0;

//Configure your own time units for in arguments etc!
var msTable = {
    //Reallife time
    'y': 31556926000, //365.25 days for taking leap years into account
    'mon': 2629743830, //
    'w': 604800000,
    'd': 86400000,
    'h': 3600000,
    'min': 60000,
    's': 1000,
    'ms': 1,
};


function handleError(error, logsToConsole, target) {
	if(typeof(logsToConsole) == typeof(undefined) || logsToConsole === null) { logsToConsole = true; }
	if(typeof(target) == typeof(undefined) || target === null) { target = null; }
    var world = API.getIWorld(0);

    var errinfo = "";
    if(error.fileName) {
        errinfo += "$6Error in "+error.fileName+(error.lineNumber?':'+error.lineNumber:"")+"\n";
    }
    if(error.message) {
        errinfo += "$e"+error.message.replaceAll("&", "")+"\n";
    }
    if(error.stack) {
        errinfo += "$r\n"+error.stack+"\n";
    }
    var errorTxt = "&cScript error in "+error.fileName+(error.lineNumber? ":"+error.lineNumber : '')+"! &n&c[Error Info]{*|show_text:"+errinfo.replaceAll("&", "")+"}&r";
    if(logsToConsole) {
        print("Error in "+error.fileName+":"+error.lineNumber+"\n"+error.message+"\n\n"+error.stack);
    }
    executeCommandGlobal("/tellraw "+(target||"@a")+" "+strf(errorTxt));
}

var File = Java.type("java.io.File");
var Files = Java.type("java.nio.file.Files");
var Paths = Java.type("java.nio.file.Paths");
var CHARSET_UTF_8 = Java.type("java.nio.charset.StandardCharsets").UTF_8;


function mkPath(path) {
	var expath = path.split("/");
	var curpath = "";
	for(var ex in expath) {
		var expt = expath[ex];
		curpath += (curpath == "" ? "" : "/")+expt;
		var pfile = new File(curpath);
		if(!pfile.exists()) {
			if(expt.match(/[\w]+\.[\w]+/) === null) { //is dir?
				pfile.mkdir();
			} else {
				pfile.createNewFile();
			}
		}
	}
}

function readDir(dirPath){
	var res = [];
	var files = new File(dirPath).listFiles();
	for(var id in files) {
var file = files[id];
		if(file.isDirectory())
			res = res.concat( readDir(file.toString()) );
		else
			res.push( Java.from( readFile(file.toString()) ).join("\n").replace(/\t/g, "  ") );
	}
	return res;
}

function readFileAsString(filePath) {
	try {
		return Java.from( readFile(filePath) ).join("\n").replace(/\t/g, "  ");
		
	} catch(exc) {
		return readFile(filePath).join("\n").replace(/\t/g, "  ");
	}
}


function readFile(filePath){
	var path = Paths.get(filePath);
	try{
		var lines = Files.readAllLines(path, CHARSET_UTF_8);
		return lines;
	} catch (e){
		return [];
	}
}

function writeToFile(filePath, text, offset, length) {
	if(typeof(offset) == typeof(undefined) || offset === null) { offset = null; }
	if(typeof(length) == typeof(undefined) || length === null) { length = null; }
	var path = Paths.get(filePath);
	try {
		var writer = Files.newBufferedWriter(path, CHARSET_UTF_8);
		writer.write(text, offset||0, length||text.length);
		writer.close();
		return true;
	} catch (exc) {
		return false
	}
}

//==Reallife date handler for hiring regions etc

Date.prototype.addTime = function(addTime) {
    this.setTime(this.getTime() + addTime);
};

Date.prototype.hasPassed = function(passDate) {
    return (this.getTime() >= passDate.getTime());
};

//Converts TimeString to number
function getStringTime(timeString) {
    //0y4mon3d 6h 8min3s 800ms
    var reg = /([\d]+)([a-zA-Z]+)/g;
    var _m = timeString.match(reg);
    var newTime = NaN;
    var _tk = Object.keys(msTable);

    for (var m in _m) {
        var fm = _m[m];
        var nm = fm.replace(reg, '$1').cInt();
        var om = fm.replace(reg, '$2');
        if (nm != null) {
            if (isNaN(newTime)) { newTime = 0; }
            if (_tk.indexOf(om) != -1) {
                newTime += nm * (msTable[_tk[_tk.indexOf(om)]]);
            } else { newTime += nm; }
        }
    }

    return newTime;
}
//Converts number to TimeString
function getTimeString(stringTime, excludes) {
	if(typeof(excludes) == typeof(undefined) || excludes === null) { excludes = []; }
    var newTime = parseInt(stringTime);
    var newStr = '';
    for (var ms in msTable) {
        if (excludes.indexOf(ms) == -1) {
            var msnum = 0;
            while (newTime >= msTable[ms]) {
                msnum++;
                newTime -= msTable[ms];
            }
            if (msnum > 0) {
                newStr += msnum.toString() + ms;
            }
        }
    }


    return newStr;
}


function getDateString(val) {
    var date = new Date();
    date.setTime(val);

    var showDay = date.getDate();
    var showMonth = (date.getMonth() + 1).toString().padStart(2, '0');
    var showYear = date.getFullYear();

    var showHours = date.getHours().toString().padStart(2, '0');
    var showMins = date.getMinutes().toString().padStart(2, '0');
    var showSecs = date.getSeconds().toString().padStart(2, '0');

    return showDay + '/' + showMonth + '/' + showYear + ' ' + showHours + ':' + showMins + ':' + showSecs;
}function getFnArgs(fn) {
	var fnrgx = /function[\s]+([\w]+)\(([\w,\s]+)\)/;
	var fnstr = fn.toString();
	var fnargs = [];
	var m = fnstr.match(fnrgx);
	if(m != null) {
		
      	m[2].split(',').forEach(function(a){
        	fnargs.push(a.trim());
        });
      	
      	return fnargs;
	}
	
	return fnargs;
}
//Convert object to array
function objArray(obj) {
    var a = [];
    for(var i in obj) {
var o = obj[i];
        a.push(o);
    }
    return a;
}

function clone(obj) {
    var copy;

    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
}

function getObjectProp(obj, prop) {
    var objRgx = /([\w]+)(?:\[(\d+)\])?/g;
    var match;
    while ((match = objRgx.exec(prop)) !== null) {
        //handle key
        if (typeof obj[match[1]] === 'undefined') {
            return null;
        }

        obj = obj[match[1]];

        if (typeof match[2] !== 'undefined') {
            if (typeof obj[parseInt(match[2])] === 'undefined') {
                return null;
            }

            obj = obj[parseInt(match[2])];
        }
    }

    return obj
}

//Get functions in the object
function getAllFuncs(obj) {
    var props = [];

    do {
        props = props.concat(Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props.sort().filter(function(e, i, arr) {
        if (e != arr[i + 1] && typeof obj[e] == 'function') return true;
    });
}

//Merge 2 objects
function objMerge(obj1, obj2, inheritNewProps) {
	if(typeof(inheritNewProps) == typeof(undefined) || inheritNewProps === null) { inheritNewProps = true; }
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) {
        if (inheritNewProps || Object.keys(obj1).indexOf(attrname) > -1) {
            obj3[attrname] = obj2[attrname];
        }
    }
    return obj3;
}

Object.__proto__.assign = function() {
    var obj = arguments[0];

    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];
        for(var key in arg) {
var value = arg[key];
            obj[key] = value;
        }
    }

    return obj;
};

Object.__proto__.values = function(obj) {
        var vals = [];
        for (var i in obj) {
            vals.push(obj[i]);
        }

        return vals;
    }
    /* */

function formatObj(obj, tabIndex, maxDeep, maxLoop, propTypes, propType, argFn) {
	if(typeof(propTypes) == typeof(undefined) || propTypes === null) { propTypes = {}; }
	if(typeof(argFn) == typeof(undefined) || argFn === null) { argFn = null; }
    if (typeof obj === 'object' && obj !== null) {

        var tabIndex = (typeof tabIndex === 'undefined' || tabIndex == null) ? 1 : tabIndex;
        var isObjArray = isArray(obj);
        var tabs = '';
        var prevTabs = '';
        for (var i = 0; i < tabIndex; i++) {
            tabs += '  ';
            if (i < tabIndex - 1) {
                prevTabs += '  ';
            }
        }

        var str = prevTabs + '&8[\n';
        if (tabIndex <= maxDeep || maxDeep === -1 || typeof maxDeep === 'undefined') {
            var index = 0;
            for (var i in obj) {
                if (index > maxLoop && typeof maxLoop !== 'undefined' && maxLoop !== -1) {
                    str += tabs + '&e&l...\n';
                    break;
                }
                index++;
                var passPropType = propTypes[i] || null;
                var args = {
                    obj: obj,
                    tabIndex: tabIndex,
                    maxDeep: maxDeep,
                    maxLoop: maxLoop,
                    propTypes: propTypes,
                    passPropType: passPropType,
                    argFn: argFn
                };

                if (typeof argFn === 'function') {
                    argFn.apply(args);
                }

                str += tabs + (parseInt(i).toString() == i.toString() ? '&b' + i : '&c"' + i + '"') + '&7 => ' + formatObj(obj[i], args.tabIndex + 1, args.maxDeep, args.maxLoop, args.propTypes, args.passPropType, args.argFn) + ',\n';
            }
        } else {
            str += tabs + '&e&l...\n';
        }

        str += prevTabs + '&8]';
        return str;
    }
    // print(JSON.stringify([propTypes, propType]));
    switch (propType) {
        case 'money':
            obj = '&r:money:&e' + getAmountCoin(obj) + '&7';
            break;
        case 'time':
            obj = '&e' + getTimeString(obj) + '&7';
            break;
        case 'date':
            obj = '&e' + getDateString(obj) + '&7';
            break;
        default:
            if (obj == null) {
                obj = '&6&lnull&7';
            } else if (typeof obj === 'string') {
                obj = '&a"' + obj + '"&7';
            } else if (typeof obj === 'number') {
                obj = '&e' + obj.toString() + '&7';
            } else if (typeof obj === 'boolean') {
                obj = '&3' + obj.toString() + '&7';
            }
            break;
    }

    return obj;
}; /* */if(typeof(Object.values) !== "function")  {
    Object.values = function(obj){
        var v = [];
        for(var i in obj) {
var oi = obj[i];
            v.push(oi);
        }

        return v;
    }
}
if(typeof(Object.keys) !== "function")  {
    Object.keys = function(obj){
        var v = [];
        for(var i in obj) {
var oi = obj[i];
            v.push(i);
        }

        return v;
    }
}
String.prototype.allMatch = function(regx) {
    var m = this.match(regx);
    var rr = [];
    for (var mm in m) {
        var mt = m[mm];
        var rx = regx.exec(this);
        rr.push(rx);
    }

    return rr;
};


String.prototype.cmatch = function(regx) {
    return (this.match(regx) || []).length;
};

String.prototype.rangeUpper = function(min, max) {
    var str = '';
    for (var i = 0; i < this.length; i++) {
        var c = this.substring(i, i + 1); //curchar
        if (i >= min && i < max) {
            c = c.toUpperCase();
        }
        str += c.toString();
    }
    return str;
};
String.prototype.rangeLower = function(min, max) {
    var str = '';
    for (var i = 0; i < this.length; i++) {
        var c = this.substring(i, i + 1); //curchar
        if (i >= min && i < max) {
            c = c.toLowerCase();
        }
        str += c.toString();
    }
    return str;
};

String.prototype.pad = function(character, len) {
    var n = this.toString();
    for (var i = n.length; i < len; i++) {
        n += character.toString();
    }
    return n;
};

String.prototype.fill = function(payload) {
    var str = this.toString();
    for(var p in payload) {
var payl = payload[p];
        str = str.split("{" + p + "}").join(payl);
    }
    return str;
}

String.prototype.padMiddle = function(character, len) {

    var n = this.toString();
    var sc = Math.floor((len - n.length) / 2);
    var ns = '';
    for (var i = 0; i < sc; i++) {
        ns += character.toString();
    }
    ns += n;
    for (var i = 0; i < sc; i++) {
        ns += character.toString();
    }
    return ns;
};

String.prototype.cInt = function() {
    return (isNaN(parseInt(this)) ? null : parseInt(this));
};


String.prototype.append = function(ch, amount) {
    var new_str = this.toString();
    for (var i = 0; i < amount; i++) {
        if (i >= new_str.length) {
            new_str += ch.toString();
        }
    }

    return new_str;
};

String.prototype.prepend = function(ch, amount) {
    var new_str = this.toString();
    for (var i = 0; i < amount; i++) {
        if (i >= new_str.length) {
            new_str = ch.toString() + new_str;
        }
    }

    return new_str;
};

String.prototype.replaceAll = function(search, replacement) {
    var target = this.toString();
    if (typeof(search) == 'string') { search = [search]; }
    for(var s in search) {
var sr = search[s];
        target = target.split(sr).join(replacement);
    }
    return target;
};

function occurrences(string, subString, allowOverlapping, caseSensitive) {
	if(typeof(allowOverlapping) == typeof(undefined) || allowOverlapping === null) { allowOverlapping = false; }
	if(typeof(caseSensitive) == typeof(undefined) || caseSensitive === null) { caseSensitive = true; }
    string = string.toString()
    subString = subString.toString()

    if (!caseSensitive) {
        string = string.toLowerCase();
        subString = subString.toLowerCase();
    }

    if (subString.length <= 0) return (string.length + 1);

    var n = 0,
        pos = 0,
        step = allowOverlapping ? 1 : subString.length;

    while (true) {
        pos = string.indexOf(subString, pos);
        if (pos >= 0) {
            ++n;
            pos += step;
        } else break;
    }
    return n;
}

function stringIsNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}

function stringIsBool(n) {
    return (['true', 'false'].indexOf(n.toLowerCase()) > -1);
}

if (!String.prototype.padStart) {
    String.prototype.padStart = function padStart(targetLength, padString) {
        targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
        padString = (typeof padString !== 'undefined' ? padString : ' ').toString();
        if (this.length > targetLength) {
            return this.toString();
        } else {
            targetLength = targetLength - this.length;
            if (targetLength > padString.length) {
                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
            }
            return padString.slice(0, targetLength) + (this).toString();
        }
    };
}

if (!String.prototype.padEnd) {
    String.prototype.padEnd = function padEnd(targetLength, padString) {
        targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
        padString = (typeof padString !== 'undefined' ? padString : ' ').toString();
        if (this.length > targetLength) {
            return (this).toString();
        } else {
            targetLength = targetLength - this.length;
            if (targetLength > padString.length) {
                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
            }
            return (this) + padString.slice(0, targetLength);
        }
    };
}



//Check config file
var CONFIG_FILEPATH = "CustomServerTools/settings.json";

function getServerProperties() {
    var proprgxs = /([\w\-.]+)\s*=([\w\W]*?)$/gm;
    var proprgx = /([\w\-.]+)\s*=([\w\W]*?)$/m;
    var propdata = {};

    (readFileAsString('server.properties').match(proprgxs) || []).forEach(function(prop) {
        var propmeta = prop.match(proprgx);
        var propname = propmeta[1];
        var propval = propmeta[2];
        if (stringIsNumeric(propval)) {
            propval = parseFloat(propval);
        } else if (stringIsBool(propval)) {
            propval = propval === 'true';
        }

        propdata[propname] = propval
    });

    return propdata;
}

function getDiskHandler(diskname) {
	if(typeof(diskname) == typeof(undefined) || diskname === null) { diskname = null; }
    diskname = diskname || CONFIG_SERVER.USE_DISK;
    if (diskname === "DEFAULT") {
        return API.getIWorld(0).storeddata;
    }
    if (Object.keys(CONFIG_SERVER.FILE_DISKS).indexOf(diskname) > -1) {
        var disk = new CSTData().useDisk(diskname);
        return disk;
    }
    return null;
}

function saveConfiguration() {
    var configFile = new File(CONFIG_FILEPATH);

    try {

        writeToFile(CONFIG_FILEPATH, JSON.stringify(CONFIG_SERVER, null, 4));


    } catch (exc) {
        handleError(exc);
    }

}

function reloadConfiguration() {
    var configFile = new File(CONFIG_FILEPATH);

    if (!configFile.exists()) {
        mkPath(CONFIG_FILEPATH);
        writeToFile(CONFIG_FILEPATH, JSON.stringify(CONFIG_SERVER, null, 4));


    }

    try {
        var loadConf = JSON.parse(readFileAsString(CONFIG_FILEPATH))
        CONFIG_SERVER = Object.assign(CONFIG_SERVER, loadConf);

        if (Object.keys(CONFIG_SERVER).sort().join(",") !== Object.keys(loadConf).sort().join(",")) {
            writeToFile(CONFIG_FILEPATH, JSON.stringify(CONFIG_SERVER, null, 4));
        }

    } catch (exc) {
        handleError(exc);
    }

}

reloadConfiguration();


var _RAWCOLORS = {
    '0': 'black',
    '1': 'dark_blue',
    '2': 'dark_green',
    '3': 'dark_aqua',
    '4': 'dark_red',
    '5': 'dark_purple',
    '6': 'gold',
    '7': 'gray',
    '8': 'dark_gray',
    '9': 'blue',
    'a': 'green',
    'b': 'aqua',
    'c': 'red',
    'd': 'light_purple',
    'e': 'yellow',
    'f': 'white',
};

var _RAWEFFECTS = {
    'o': 'italic',
    'l': 'bold',
    'k': 'magic',
    'm': 'strike',
    'n': 'underline',
    'r': 'reset'
}

var _RAWCODES = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS));

function getColorId(name) {
    for (var i in _RAWCOLORS) {
        if (name == _RAWCOLORS[i]) {
            return i;
        }
    }
    for(var i in _RAWEFFECTS) {
var re = _RAWEFFECTS[i];
        if (name == re) {
            return i;
        }
    }
    return 'r';
}

function getColorName(id) {
    for(var i in _RAWCOLORS) {
var rc = _RAWCOLORS[i];
        if (id == i) {
            return rc;
        }
    }
    for(var i in _RAWEFFECTS) {
var re = _RAWEFFECTS[i];
        if (id == i) {
            return re;
        }
    }
    return 'white';
}

function stripColors(str) {
    for(var i in _RAWCODES) {
var rawcode = _RAWCODES[i];
        str = str.replaceAll('&' + rawcode, '');
    }

    return str;
}

function slugify(text) {
    text = stripColors(text);
    return text.toString().toLowerCase()
        .replace(/\s+/g, '_') // Replace spaces with -
        .replace(/[^\w\-]+/g, '') // Remove all non-word chars
        .replace(/__+/g, '_') // Replace multiple - with single -
        .replace(/^_+/, '') // Trim - from start of text
        .replace(/_+$/, ''); // Trim - from end of text
}

function ccs(str, af) {
	if(typeof(af) == typeof(undefined) || af === null) { af = null; }
    return colorCodeString(str, af);
}

function colorCodeString(str, allowed_formats) {
	if(typeof(allowed_formats) == typeof(undefined) || allowed_formats === null) { allowed_formats = null; }
    if (allowed_formats == null) {
        allowed_formats = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS));
    }
    allowed_formats = removeFromArray(allowed_formats, ['x', 'y']);
    return str.replace(new RegExp("&([" + allowed_formats.join("") + "])", 'g'), '\u00A7$1').replace(/&\\/g, '&');
}

function escCcs(str, esc_formats) {
	if(typeof(esc_formats) == typeof(undefined) || esc_formats === null) { esc_formats = null; }
    if (esc_formats == null) {
        esc_formats = _RAWCODES;
    }

    return str.replace(new RegExp('&([' + esc_formats.join("") + '])', 'g'), '');
}

function parseEmotes(str, allwd, replaceOld) {
	if(typeof(allwd) == typeof(undefined) || allwd === null) { allwd = []; }
	if(typeof(replaceOld) == typeof(undefined) || replaceOld === null) { replaceOld = true; }
    if (replaceOld) {
        str = str.replaceAll(Object.values(CHAT_EMOTES), '');
    }
    for (var ce in CHAT_EMOTES) {
        var chatemote = CHAT_EMOTES[ce];
        if (allwd.length == 0 || allwd.indexOf(ce) > -1) {
            str = str.replaceAll(':' + ce + ':', chatemote);
            str = str.replaceAll(':/' + ce + '/:', ':' + ce + ':');
        }
    }
    return str;
}

function strf(str, toRaw, allowed) {
	if(typeof(toRaw) == typeof(undefined) || toRaw === null) { toRaw = true; }
	if(typeof(allowed) == typeof(undefined) || allowed === null) { allowed = null; }
	return strrawformat(str, toRaw, allowed);
}
var CHAT_CMD_RGX = /{[\s]*(?:([\w]+)[\s]*\:[\s]*([\w\W\/]+?)|\*)(?:[\s]*\|[\s]*([\w]+)[\s]*\:[\s]*([\w\W\/]+?[\s]*))?}/;
var CHAT_CMD_RGX_G = /{[\s]*(?:([\w]+)[\s]*\:[\s]*([\w\W\/]+?)|\*)(?:[\s]*\|[\s]*([\w]+)[\s]*\:[\s]*([\w\W\/]+?[\s]*))?}/g;


function strrawformat(str, toRaw, allowed) {
	if(typeof(toRaw) == typeof(undefined) || toRaw === null) { toRaw = false; }
	var rf = [];
	var txt = '';
	var ri = -1;
	var isCode = false;
	var txtColor = 'white';
	var isItalic = false;
	var isBold = false;
	var isStrike = false;
	var isUnderlined = false;
	var isObf = false;
	str = str+'&r ';

	for(var i = 0; i < str.length; i++) {
		var c = str.substr(i, 1);
		if(c == '&' || i == str.length-1) {
			//Check if new section has to be made
			if(txt.length > 0) {
				ri++;
				var cmds = [];

				rf.push([txt, txtColor, isItalic, isBold, isUnderlined, isStrike, isObf]);
				isItalic = false;
				isBold = false;
				isUnderlined = false;
				isStrike = false;
				isObf = false;
				txtColor = 'white';
				txt = '';
			}
			isCode = true;
			continue;
		} else {
			if(!isCode) {
				txt += c.toString();
			} else {
				//Check Colors
				if(typeof(_RAWCOLORS[c]) != typeof(undefined)) {
					txtColor = _RAWCOLORS[c];
				}
				//Check Markup
				switch(c.toString()) {
					case 'o': {
						isItalic = true;
						break;
					}
					case 'l': {
						isBold = true;
						break;
					}
					case 'n': {
						isUnderlined = true;
						break;
					}
					case 'm': {
						isStrike = true;
						break;
					}
					case 'k': {
						isObf = true;
						break;
					}
					case 'r': {
						isItalic = false;
						isBold = false;
						isUnderlined = false;
						isStrike = false;
						isObf = false;
						txtColor = 'white';
						break;
					}
				}
				isCode = false;
			}
		}
	}

	return (!toRaw ? rf : rawformat(rf, true));
}

function rawformat(str_pieces, fullraw, allowed) {
	if(typeof(fullraw) == typeof(undefined) || fullraw === null) { fullraw = true; }
	if(typeof(allowed) == typeof(undefined) || allowed === null) { allowed = null; }
	if(allowed == null) {
		allowed = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS)).concat(['x', 'y']);

	}
	var txt = '';
	if(fullraw) { txt+='[""'; }

	for(var i in str_pieces) {
		var p = str_pieces[i];
		var ntext = p[0].replace(/\"/g, '\\"');
		var nm =  ntext.match(CHAT_CMD_RGX) || [];
		if(nm.length > 0) {
			p[7] = nm[1];
			p[8] = nm[2];
			p[9] = nm[3];
			p[10] = nm[4];
			ntext = ntext.replace(nm[0], '');
		}
		var pc = '{"text":"'+ntext+'"';
		if(p[1]) {
			if(allowed.indexOf(getColorId(p[1])) == -1) {
				p[1] = 'white';
			}

			pc+=',"color":"'+p[1].toString()+'"';

		}
		if(p[2]) {
			if(allowed.indexOf('o') > -1) {
				pc+=',"italic":true';
			}
		}
		if(p[3]) {
			if(allowed.indexOf('l') > -1) {
				pc+=',"bold":true';
			}
		}
		if(p[4]) {
			if(allowed.indexOf('n') > -1) {
				pc+=',"underlined":true';
			}
		}
		if(p[5]) {
			if(allowed.indexOf('m') > -1) {
				pc+=',"strikethrough":true';
			}
		}
		if(p[6]) {
			if(allowed.indexOf('k') > -1) {
				pc+=',"obfuscated":true';
			}
		}

		if(p[7] && p[8]) { pc+=',"clickEvent":{"action":"'+p[7]+'","value":"'+p[8]+'"}'; }
		if(p[9] && p[10]) { pc+=',"hoverEvent":{"action":"'+p[9]+'","value":"'+ccs((p[10]||"").replace(/\$/g, '\u00A7'),allowed)+'"}'; }
		pc += '}';


		txt+=( fullraw ? ',' : '' )+pc.toString();
	}

	if(fullraw) {
		txt += ']';
	}

	return txt;
}

/**
 * 
 * @param {Number} value Current value
 * @param {Number} max Maximum value
 * @param {Number} length Character length
 * @param {String||'|'} progChar Progressbar character
 * @param {String} fillColor Filled color code '&a'
 * @param {String} leftColor Filles color code '&c'
 */
function progressBar(value, max, length, progChar, fillColor, leftColor, opener, closer){
	if(typeof(progChar) == typeof(undefined) || progChar === null) { progChar = null; }
	if(typeof(fillColor) == typeof(undefined) || fillColor === null) { fillColor = '&a'; }
	if(typeof(leftColor) == typeof(undefined) || leftColor === null) { leftColor = '&c'; }
	if(typeof(opener) == typeof(undefined) || opener === null) { opener = '&l['; }
	if(typeof(closer) == typeof(undefined) || closer === null) { closer = '&l]'; }
	var skillBar = '&r'+opener+'&r';
	var progress = Math.floor((value/max)*length);
	var proc = Math.round(value/max*100);
	for(var i = 0; i < length; i++) {
		if(i < progress) skillBar += fillColor+(progChar||'|');
		if(i >= progress) skillBar += leftColor+(progChar||'|');
	}
	return skillBar += '&r'+closer+'&r';
}


//Send player formatted message
function tellPlayer(player, rawtext) {
    return executeCommand(player, "/tellraw " + player.getName() + " " + parseEmotes(strf(rawtext)));
}

function tellTarget(player, target, rawtext) {
    return executeCommand(player, "/tellraw " + target + " " + parseEmotes(strf(rawtext)));
}

function tellPlayerTitle(player, rawtext, type, target) {
	if(typeof(type) == typeof(undefined) || type === null) { type = "actionbar"; }
    return executeCommand(player, "/title " + (target || player.getName()) + " " + type + " " + parseEmotes(strf(rawtext)))
}
//Send player multiple formatted messages from array
function storytellPlayer(player, ar) {
    for(var i in ar) {
var ari = ar[i];
        tellPlayer(player, ari);
    }
}

//Get server title bar for displaying
//TO-DO: Placeholders instead of multiple variables
function getTitleBar(title, showServerName) {
	if(typeof(showServerName) == typeof(undefined) || showServerName === null) { showServerName = true; }
    return CONFIG_SERVER.BAR_OPEN + (showServerName ? CONFIG_SERVER.TITLE + " " : CONFIG_SERVER.PREFIX) + title + CONFIG_SERVER.BAR_CLOSE;
}

function getNavBar() {
    return "&6[[ &e[My Money]{run_command:!myMoney|show_text:$eClick to view your money.}&6 || " +
        "&e[My Banks]{run_command:!myBanks|show_text:$eClick here to view your bank accounts.}&6 || " +
        "&e[My Loan]{run_command:!myLoan|show_text:$eClick here to view your current active loan.}&6 || \n" +
        "&e[My Emotes]{run_command:!myEmotes|show_text:$eClick here to view your emotes.}&6 || " +
        "&e[My Regions]{run_command:!myRegions|show_text:$eClick here to view your regions.}&6 ]]";
}

function getUndoBtn(undo_cmds, hoverText) {
	if(typeof(hoverText) == typeof(undefined) || hoverText === null) { hoverText = null; }
    return "&r[" + _MSG['undoBtnText'] + "{run_command:!chain ;" + undo_cmds.join(";") + (hoverText == null ? "" : "|show_text:" + hoverText.toString()) + "}&r]";
}



//Java import


//UUIDLeast-Most
function UUIDLM() { return rrandom_range(1, 99999); }

function getDropChance(npcnbt, slot) {
	var dropC = npcnbt.getList('DropChance', 10);
	var dropChance = parseInt(dropC[slot].getInteger('Integer'));

	return dropChance;
}




function getHandItem(player) {
	return player.getMainhandItem() || player.getOffhandItem();
}

//Get unique ID
function uniqid() {
	var id = '';
	for(var i = 0; i <= 3; i++) {
		id+=Math.random().toString(36).substr(2, 9);
	}
	return id;
}

//Vanilla item attributes
var _ITEMATTR = [
	'generic.attackDamage',
	'generic.followRange',
	'generic.maxHealth',
	'generic.followRange',
	'generic.knockbackResistance',
	'generic.movementSpeed',
	'generic.armor',
	'generic.armorToughness',
	'generic.attackSpeed',
	'generic.luck',
	'generic.attackKnockback',
	'generic.flyingSpeed',
	'generic.luck'
];

//Escape JSON symbols
function escapeNbtJson(json, trim_ends) {
	if(typeof(trim_ends) == typeof(undefined) || trim_ends === null) { trim_ends = true; }
	json = json.replace(/(?:\\n|\\)/g, '');
	json = json.replace(/(\d) ([fbds]+)/g, "$1$2");
	json = json.replace(/\\("|')/g, "$1");
	if(trim_ends) {
		json = json.slice(1, json.length - 1);
	}

	return json;
}

function getDayTime(time) {
	while(time > 24000) { time -= 24000; }
	return time;
}

function isArray(obj) {
	if(typeof(obj) === 'object') {
      for(var k in obj) {
          if(isNaN(k)) {
			  return false;
		  }
      }
      return true;
    } else { return false }
}

function isObject(obj) {
	return ( typeof(obj) === 'object' && !isArray(obj) );
}


var _COMMANDS = [];
var _DATAHANDLERS = {};
//To-Do: Comment this file

/**
 * 
 * @param {Array} items Items to show
 * @param {Array} matches (Default: [])Matches to filter on
 * @param {Number} showLen (Default: 10)Items to show per page
 * @param {Number} curPage (Default: 1)Current page to output
 * @param {String} navCmd Base command to generate new navigation commands on
 * @param {Function} listingFn (item, index) Function that returns string as one item in list (line break needed)
 * @param {Function} sortFn Function to sort items
 * @param {Function} compareFn (item,matches)Custom Function to check if item is allowed in list
 * @param {Enum("ASC", "DESC")} sortDesc (Default: ASC)Desc will reverse the items after sorting
 * @param {String} toptext The text above the results, below the help buttons
 */
function genDataPageList(items, matches, showLen, curPage, navCmd, listingFn, sortFn, compareFn, sortDesc, toptext) {
	if(typeof(matches) == typeof(undefined) || matches === null) { matches = []; }
	if(typeof(showLen) == typeof(undefined) || showLen === null) { showLen = 10; }
	if(typeof(curPage) == typeof(undefined) || curPage === null) { curPage = 1; }
	if(typeof(navCmd) == typeof(undefined) || navCmd === null) { navCmd = null; }
	if(typeof(listingFn) == typeof(undefined) || listingFn === null) { listingFn = null; }
	if(typeof(sortFn) == typeof(undefined) || sortFn === null) { sortFn = null; }
	if(typeof(compareFn) == typeof(undefined) || compareFn === null) { compareFn = null; }
	if(typeof(sortDesc) == typeof(undefined) || sortDesc === null) { sortDesc = false; }
	if(typeof(toptext) == typeof(undefined) || toptext === null) { toptext = ''; }


    var output = "";
    //Sanitize
    for(var i in matches) {
var match = matches[i];
        matches[i] = match.replace(/[^*\w]/g, "");
    }

    //Limit showLen
    showLen = Math.max(Math.min(showLen, 32), 4);

    //get excludes from matches
    var excludes = [];
    var excludeRgx = /\*([\w]+)/;
    var newMatches = [];
    for(var a in matches) {
var match = matches[a];
        (match.cmatch(excludeRgx) > 0 ? excludes : newMatches).push(match.replace(excludeRgx, "$1"));
    }
    matches = newMatches;

    var minShow = (parseInt(curPage) - 1) * showLen;
    var maxShow = minShow + showLen;

    var curShow = 0;

    var tellItems = [];
    //Sort items
    items.sort(typeof sortFn === "function" ? sortFn : function(a, b) {
        var al = a.toLowerCase();
        var bl = b.toLowerCase();

        if (al < bl) return -1;
        if (al > bl) return 1;

        return 0;
    });


    if (sortDesc) {
        items.reverse();
    }
    //Filter items
    for(var i in items) {
var item = items[i];
        var isExcluded = (compareFn == null ? arrayOccurs(item, excludes, false, false) > 0 : compareFn(item, excludes));
        if (matches.length == 0 || (compareFn == null ? arrayOccurs(item, matches, false, false) > 0 : compareFn(item, matches))) {
            if (!isExcluded) {
                if (curShow >= minShow && curShow < maxShow && tellItems.indexOf(item) == -1) {
                    tellItems.push(item)
                }
                curShow++;
            }
        }
    }

    function genNavCmd(_page, _showLen, _sort) {
	if(typeof(_page) == typeof(undefined) || _page === null) { _page = curPage; }
	if(typeof(_showLen) == typeof(undefined) || _showLen === null) { _showLen = showLen; }
	if(typeof(_sort) == typeof(undefined) || _sort === null) { _sort = sortDesc; }
        return navCmd.fill({
            "MATCHES": matches.join(" ") + " " + arrayFormat(excludes, "*{VALUE}"),
            "PAGE": _page,
            "SHOWLEN": _showLen, //Backwards compatability for some plugins
            "SHOW": _showLen, //New change
            "SORT": (_sort ? "desc" : "asc")
        });
    }

    var gCmd = genNavCmd();
    output += "&3[Copy Command]{suggest_command:" + gCmd + "|show_text:$3Click to get the command that shows exactly this page.}&r" +
        " &5[? Help]{*|show_text:$dAdd words divided by a space to search for them.\nTo Exclude something, put '*' in front.\nYou can also combine it to get more specific results.}&r\n";

    if (toptext) {
        output += toptext + '\n';
    }

    if (matches.length > 0) {
        output += "&6&lSearching for: &e" + matches.join(", ") + "\n";
    }
    if (excludes.length > 0) {
        output += "&6&lExcluding: &e" + excludes.join(", ") + "\n";
    }
    output += "&6&lSorting: &e" + (sortDesc ? "De" : "A") + "scending&r &b[Toggle]{run_command:" + genNavCmd(curPage, showLen, !sortDesc) + "|show_text:$3Click to toggle sorting type (asc/desc).}\n";
    output += "&6&lResults Found: &a" + curShow + " &eof &a" + items.length + "\n";

    var maxPages = Math.ceil(curShow / showLen);

    var showLenOptions = [
        5,
        10,
        15,
        20
    ];
    var sloTxt = "";
    for(var s in showLenOptions) {
var slo = showLenOptions[s];
        var showLenCmd = genNavCmd(Math.round(curPage * (showLen / slo)), slo)

        sloTxt += "&b[Show " + slo + "]{run_command:" + showLenCmd + "|show_text:$3Click to show " + slo.toString() + " results per page.}&r ";
    }

    output += sloTxt + "\n";

    var navBtns = "";
    if (navCmd != null) {
        var matchCmd = matches.join(" ") + " " + arrayFormat(excludes, "*{VALUE}");
        var prevCmd = genNavCmd(parseInt(curPage) - 1);
        var nextCmd = genNavCmd(parseInt(curPage) + 1);
        var prevBtn = curPage > 1 ? " &9[<< Previous]{run_command:" + prevCmd + "|show_text:$9Click to go to previous page.}&r" : "";
        var nextBtn = curPage < maxPages ? " &a[Next >>]{run_command:" + nextCmd + "|show_text:$aClick to go to next page.}&r" : "";
        navBtns = prevBtn + nextBtn;
    }

    if (tellItems.length > 0) {
        output += "&6&lPage: &5&l" + curPage + "/" + maxPages + "&r" + navBtns + "\n";

        for(var i in tellItems) {
var tellItem = tellItems[i];
            output += (listingFn == null ? " - &b&l" + tellItem + "&r\n" : listingFn(tellItem, i));
        }
    } else {
        output += "&cNothing found with given criteria.";
    }

    return output;
}

var _CMD_HISTORY = {};
var tempdata = API.getIWorld(0).tempdata;
if (!tempdata.has('xCommandCache')) {
    tempdata.put('xCommandCache', _CMD_HISTORY);
} else {
    _CMD_HISTORY = tempdata.get('xCommandCache');
}

function queryDataHandlers(qry) {

}

function registerDataHandler(alias, dataHandlerFn) {
    _DATAHANDLERS[alias] = dataHandlerFn;
}

function getDataHandler(alias) {
    return _DATAHANDLERS[alias];
}

function registerXCommand(commandMatch, callback, perm, rules, payload) {
	if(typeof(rules) == typeof(undefined) || rules === null) { rules = []; }
	if(typeof(payload) == typeof(undefined) || payload === null) { payload = {}; }
    _COMMANDS.push({
        usage: commandMatch,
        callback: callback,
        perm: perm,
        rules: rules,
        enabled: true,
        payload: payload,
    });
}

function getCommandNoArg(cmdstr) {
    return cmdstr.match(/![\w\s]+/)[0];
}

function matchXCommands(cmdstrs) {
	if(typeof(cmdstrs) == typeof(undefined) || cmdstrs === null) { cmdstrs = []; }
    if (typeof(cmdstrs) == 'string') { cmdstrs = [cmdstrs]; }
    var cmds = [];

    for(var c in _COMMANDS) {
var command = _COMMANDS[c];
        for(var ci in cmdstrs) {
var cmdstr = cmdstrs[ci];
            var cname = getCommandNoArg(command.usage).trim();
            if (cmdstr.substr(0, 1) == "^") {
                if ((cmdstrs.length == 0 || occurrences(cname, cmdstr.substr(1, cmdstr.length)) == 0) && cmds.indexOf(command) == -1) {
                    cmds.push(command);
                    break;
                }
            } else {
                if ((cmdstrs.length == 0 || occurrences(cname, cmdstr) > 0) && cmds.indexOf(command) == -1) {
                    cmds.push(command);
                    break;
                }
            }
        }
    }

    return cmds;
}

function getCommandName(cmdstr) {
    var cmda = getCommandNoArg(cmdstr).trim(); //Remove whitespace around
    return cmda.substr(1, cmda.length); //Remove '!'-character
}

function getCommandPerm(cmdstr) {
    return getCommandName(cmdstr).replace(/\s+/g, '.');
}

function registerXCommands(cmds) {
    for (var c in cmds) {
        registerXCommand(cmds[c][0], cmds[c][1], cmds[c][2], cmds[c][3] || [], cmds[c][4] || {});
    }
}

function CommandFactory(datahandler, cmdtree) {
    this.type = datahandler;
    this.cmdtree = cmdtree || datahandler;
    this.cmds = [];
    this.info = [];
    this.listingTransformer = null;
    this.listingTransformerFn = null;
    this.listingRequirement = null;
    this.onFns = {
        "create": [],
        "remove": [],
        "info": [],
        "list": [],
        "copy": [],
    };

    //Event functions
    this.on = function(action, callback) {
        this.onFns[action].push(callback);
        return this;
    };

    //Command Building functions
    this.addInfoText = function(infoFn) {
        this.info.push(infoFn);
        return this;
    };
    this.add = function(subCommand, fn, rules, payload, dhNameArg, dhMustExists) {
	if(typeof(rules) == typeof(undefined) || rules === null) { rules = []; }
	if(typeof(payload) == typeof(undefined) || payload === null) { payload = {}; }
	if(typeof(dhNameArg) == typeof(undefined) || dhNameArg === null) { dhNameArg = "name"; }
	if(typeof(dhMustExists) == typeof(undefined) || dhMustExists === null) { dhMustExists = true; }
        payload = objMerge({
            "datatype": this.type,
            "cmdtree": this.cmdtree,
            "argname": dhNameArg,
            "fn": fn,
        }, payload);
        var cmdstr = "!" + this.cmdtree + " " + subCommand;
        this.cmds.push([
            cmdstr,
            function(pl, args, data, cdata) {
                var dht = getDataHandler(cdata.datatype);
                var dh = new dht(args[cdata.argname]).init(data, false);
                return cdata.fn(dh, pl, args, data, cdata);
            },
            getCommandPerm(cmdstr),
            rules.concat([{
                "argname": dhNameArg,
                "type": "datahandler",
                "datatype": this.type,
                "exists": dhMustExists
            }]),
            payload
        ]);
        return this;
    };
    this.addSettable = function(property, argTransformFn, rules, outputTransform, argNode, argName) {
	if(typeof(argTransformFn) == typeof(undefined) || argTransformFn === null) { argTransformFn = null; }
	if(typeof(rules) == typeof(undefined) || rules === null) { rules = []; }
	if(typeof(outputTransform) == typeof(undefined) || outputTransform === null) { outputTransform = null; }
        var propname = property.rangeUpper(0, 1);
        var out = objMerge({
            "val": "\"{" + property + "}\"",
        }, (outputTransform || {}));
        argName = argName || property;
        argNode = (argNode || "<{NAME}>").fill({
            "NAME": argName,
        });
        this.cmds.push([
            '!' + this.cmdtree + ' set' + propname + ' <name> ' + argNode,
            function(pl, args, data, cdata) {
                var dht = getDataHandler(cdata.datatype);
                var dh = new dht(args.name);
                var val = args[cdata.argname];
                dh.load(data);
                dh.data[cdata.property] = (argTransformFn == null ? val : argTransformFn(val, dh, pl, args, data, cdata));
                dh.save(data);
                var tellData = {};
                tellData[cdata.property] = val;
                tellPlayer(pl, "&aSet property &2\"" + property + "\"&a of " + dh.type + " &2\"" + dh.name + "\"&a to " + cdata.out.val.fill(tellData) + "&r&a!");
                return true;
            },
            this.cmdtree.replaceAll(" ", ".") + '.set' + propname,
            rules.concat([{
                "argname": "name",
                "type": "datahandler",
                "datatype": this.type,
                "exists": true,
            }]),
            {
                "datatype": this.type,
                "cmdtree": this.cmdtree,
                "property": property,
                "propname": propname,
                "argname": argName,
                "argnode": argNode,
                "out": out,
            },
        ]);

        return this;
    };
    this.setListTransformer = function(transformFn) {
        this.listingTransformerFn = transformFn;

        return this;
    };
    //Generate Functions
    this.genDefault = function(excludes) {
	if(typeof(excludes) == typeof(undefined) || excludes === null) { excludes = []; }
        if (excludes.indexOf("create") == -1)
            this.cmds.push(
                ['!' + this.cmdtree + ' create <name>', function(pl, args, data, cdata) {
                    var dht = getDataHandler(cdata.datatype);
                    var dh = new dht(args.name);
                    var payload = {
                        "cancel": false,
                    };
                    for(var o in cdata.self.onFns['create']) {
var onFn = cdata.self.onFns['create'][o];
                        onFn(dh, pl, args, data, cdata, payload);
                    }

                    if (!payload.cancel) {
                        dh.save(data);
                        tellPlayer(pl, "&aCreated " + dh.type + " &2'" + dh.name + "'&a!");
                        return true;
                    }
                    return false;
                }, this.cmdtree.replaceAll(" ", ".") + '.create', [{
                        "argname": "name",
                        "type": "string",
                        "noColor": true,
                    },
                    {
                        "argname": "name",
                        "type": "datahandler",
                        "datatype": this.type,
                        "exists": false,
                    },
                ], {
                    "datatype": this.type,
                    "self": this,
                }]);
        if (excludes.indexOf("remove") == -1)
            this.cmds.push(
                ['!' + this.cmdtree + ' remove <name>', function(pl, args, data, cdata) {
                    var dht = getDataHandler(cdata.datatype);
                    var dh = new dht(args.name);
                    for(var o in cdata.self.onFns['remove']) {
var onFn = cdata.self.onFns['remove'][o];
                        onFn(dh, pl, args, data, cdata, payload);
                    }
                    dh.remove(data);
                    tellPlayer(pl, "&aRemoved " + dh.type + " '" + dh.name + "'!");
                    return true;
                }, this.cmdtree.replaceAll(" ", ".") + '.remove', [{
                    "argname": "name",
                    "type": "datahandler",
                    "datatype": this.type,
                    "exists": true,
                }], {
                    "datatype": this.type,
                    "self": this,
                }]);
        if (excludes.indexOf("info") == -1)
            this.cmds.push(
                ['!' + this.cmdtree + ' info <name>', function(pl, args, data, cdata) {
                    var dht = getDataHandler(cdata.datatype);
                    var dh = new dht(args.name);
                    dh.load(data);
                    var typename = dh.type.rangeUpper(0, 1);
                    tellPlayer(pl, getTitleBar(typename + " Info", false));
                    tellPlayer(pl, "[&2:recycle: Refresh{run_command:!" + cdata.cmdtree + " info " + dh.name + "|show_text:$aClick to reload " + cdata.datatype + " info.}&r]\n" +
                        "&6&l" + typename + " Name: &b" + dh.name + "&r [&4:cross_mark: Remove{run_command:!" + cdata.cmdtree + " remove " + dh.name + "|show_text:$cClick to remove " + dh.type + "}&r]");
                    if ("getPermission" in dh) {
                        var dhp = dh.getPermission().init(data, false);
                        tellPlayer(pl, "&6&lPermission: &9" + dhp.name + "&r [&e:sun: Info{run_command:!perms info " + dhp.name + "}&r]")
                    }
                    var tellInfo = "";
                    for(var i in cdata.info) {
var infoFn = cdata.info[i];
                        tellInfo += infoFn(dh, pl, args, data, cdata);
                    }
                    if (tellInfo != "") {
                        tellPlayer(pl, tellInfo);
                    }

                    for(var o in cdata.self.onFns['info']) {
var onFn = cdata.self.onFns['info'][o];
                        onFn(dh, pl, args, data, cdata);
                    }

                    return true;
                }, this.cmdtree.replaceAll(" ", ".") + '.info', [{
                    "argname": "name",
                    "type": "datahandler",
                    "datatype": this.type,
                    "exists": true,
                }], {
                    "self": this,
                    "datatype": this.type,
                    "cmdtree": this.cmdtree,
                    "info": this.info,
                    "exc": excludes
                }]);
        if (excludes.indexOf("list") == -1)
            this.cmds.push(
                ['!' + this.cmdtree + ' list [...matches]', function(pl, args, data, cdata) {
                        var w = pl.world;
                        var sb = w.getScoreboard();
                        var dht = getDataHandler(cdata.datatype);
                        var params = getArgParams(args.matches);

                        var de = new dht().getAllDataEntries(data);
                        for(var o in cdata.self.onFns['list']) {
var onFn = cdata.self.onFns['list'][o];
                            onFn(dh, pl, args, data, cdata);
                        }
                        var txt = getTitleBar(cdata.datatype.rangeUpper(0, 1) + " List") + "\n";
                        txt += genDataPageList(
                            de,
                            args.matches,
                            parseInt(params.show || 10),
                            parseInt(params.page || 1),
                            "!" + cdata.cmdtree + " list {MATCHES} -page:{PAGE} -show:{SHOWLEN} -sort:{SORT}",
                            function(item) {
                                return cdata.ltfn == null ? ("&e - &b" + item.name + "&r\n") : cdata.ltfn(item, pl, args, data);
                            },
                            function(a, b) {
                                var aa = a.name;
                                var bb = b.name;
                                if (aa < bb) return -1;
                                if (aa > bb) return 1;
                                return 0;
                            },
                            function(cmd, list) {
                                return arrayOccurs(cmd.name, list, false, false);
                            },
                            (params.sort || "").toLowerCase() == "desc"
                        );

                        tellPlayer(pl, txt);
                        return true;
                    }, this.cmdtree.replaceAll(" ", ".") + '.list', [],
                    {
                        "self": this,
                        "datatype": this.type,
                        "cmdtree": this.cmdtree,
                        "lt": this.listingTransformer,
                        "ltfn": this.listingTransformerFn,
                    },
                ]);
        if (excludes.indexOf("copy") == -1)
            this.cmds.push(
                ['!' + this.cmdtree + ' copy <name> <new_name>', function(pl, args, data, cdata) {
                    var dht = getDataHandler(cdata.datatype);
                    var dh = new dht(args.name).init(data);
                    for(var o in cdata.self.onFns['copy']) {
var onFn = cdata.self.onFns['copy'][o];
                        onFn(dh, pl, args, data, cdata);
                    }
                    dh.name = args.new_name;
                    dh.save(data);
                    tellPlayer(pl, "&aCopied " + dh.type + " '" + args.name + "' to '" + args.new_name + "'!");
                    return true;
                }, this.cmdtree.replaceAll(" ", ".") + '.copy', [{
                        "argname": "new_name",
                        "type": "string",
                        "noColor": true,
                    },
                    {
                        "argname": "name",
                        "type": "datahandler",
                        "datatype": this.type,
                        "exists": true,
                    },
                    {
                        "argname": "new_name",
                        "type": "datahandler",
                        "datatype": this.type,
                        "exists": false
                    }
                ], {
                    "datatype": this.type,
                    "self": this,
                }]);
        return this;
    };
    this.register = function() {
        registerXCommands(this.cmds);
        return this;
    };
}


function parseUsageRgx(command, str) {
	if(typeof(str) == typeof(undefined) || str === null) { str = null; } //Converts command usage to Regex, and gathers info about command
    //!perms\s+manage\s+add((?:\s+[\w]+))((?:\s+[\w]+)*)
    //+ == <...vars> //multiple args, minimal one required
    //* == [...vars] //multiple args, optional
    //  == <var> //arg, required
    //? == [var] // arg, optional

    var argrx = [];
    var cmdMatch = command.usage
        .replace(/(\w)\s+(\w)/g, "$1\\s+$2")
        .replace(/(\w|>|\])\s+(\w|<|\[)/g, "$1$2"); //fix whitespace
    var req_regx = /<([.]{3})*([\w]+)>/g; //Required arg regex
    var opt_regx = /\[([.]{3})*([\w]+)\]/g; //Optional arg recalc
    var rm = cmdMatch.allMatch(req_regx);
    for (var i in rm) { //required args
        var rmcode = rm[i][0];
        var rmmulti = (rm[i][1] != null);
        var rmname = rm[i][2];
        var rmpart = "((?:\\s+\\S+)" + (rmmulti ? "+" : "") + ")";
        if (str != null) {
            argrx.push([
                command.usage.indexOf(rmcode),
                rmname,
                rmmulti
            ]);
        }
        cmdMatch = cmdMatch.replace(rmcode, rmpart);
    }
    var om = cmdMatch.allMatch(opt_regx);
    for (var i in om) { //optional args
        var omcode = om[i][0];
        var ommulti = (om[i][1] != null);
        var omname = om[i][2];
        var ompart = "((?:\\s+\\S+)" + (ommulti ? "*" : "?") + ")";
        if (str != null) {
            argrx.push([
                command.usage.indexOf(omcode),
                omname,
                ommulti
            ]);
        }
        cmdMatch = cmdMatch.replace(omcode, ompart);
    }

    var capt_names = [];
    var cids = [];

    while (argrx.length > 0) {
        var hid = 0;
        for (var i in argrx) {
            if (argrx[i][0] > hid) {
                hid = argrx[i][0];
            }
        }
        for (var i in argrx) {
            if (argrx[i][0] == hid) {
                capt_names.push([argrx[i][1], argrx[i][2]]);
                argrx.splice(i, 1);
                break;
            }
        }
    }
    capt_names.reverse();

    return [cmdMatch, capt_names];
}

var ARGPARAM_REGEX = /-([\w]+)(?:\s*:\s*([\w\S]+))?/;

function getArgParams(arr) {
    var params = {};
    var remParams = [];
    for(var i in arr) {
var a = arr[i];
        var am = a.match(ARGPARAM_REGEX);
        if (am != null) {
            params[am[1]] = (am[2] === undefined ? true : am[2]);
            remParams.push(am[0]);
        }
    }
    for(var re in remParams) {
var remPar = remParams[re];
        array_remove(arr, remPar);
    }
    return params;
}

function executeXCommand(str, player, permcheck, data) {
	if(typeof(permcheck) == typeof(undefined) || permcheck === null) { permcheck = true; }
    var data = data || player.world.getStoreddata();
    var sb = player.world.getScoreboard();
    for(var c in _COMMANDS) {
var cmd = _COMMANDS[c];
        var cmdm = parseUsageRgx(cmd, str);

        var argrgx = cmdm[0];
        var rgx = new RegExp(argrgx, 'gi');
        if ((str.match(rgx) || []).length == 1) {
            if (str.indexOf(str.match(rgx)[0]) == 0 && str.replace(rgx, '') == '') {
                var argnames = cmdm[1];
                var cg = 1;
                var args = {};
                for (var a in argnames) {
                    var argname = argnames[a][0];
                    var ismulti = argnames[a][1];
                    if (typeof(args[argname]) == typeof(undefined)) {
                        args[argname] = (ismulti ? [] : null)
                    }
                    var argval = str.replace(rgx, '$' + cg.toString());
                    if (ismulti) {
                        args[argname] = argval.split(' ');
                        args[argname] = args[argname].filter(function(el) {
                            return el.toString().length > 0;
                        });
                    } else {
                        args[argname] = (argval.trim() == "" ? null : argval.trim());
                    }


                    cg++;
                }

                var cmdperm = new Permission(cmd.perm);
                if (!cmdperm.exists(data)) {
                    cmdperm.save(data);
                }
                cmdperm.load(data);
                if (cmdperm.permits(player.getName(), sb, data) || !permcheck) {
                    //Check arguments
                    for(var a in args) {
var arg = args[a];
                        if (arg == null) { continue; }

                        for(var b in cmd.rules) {
var rule = cmd.rules[b];

                            if (!("argname" in rule)) { continue; }
                            var errpref = '';
                            var errsuff = '';
                            if ("msgprefix" in rule) { errpref = rule.msgprefix }
                            if ("msgsuffix" in rule) { errsuff = rule.msgsuffix }

                            if ("as" in rule) {
                                if (rule.as == "string" && typeof arg == 'object') {
                                    arg = arg.join(" ");
                                }
                            }

                            if (rule.argname != a) { continue; }
                            var rulename = rule.name || rule.argname.toString();
                            if ('type' in rule) { //Check Arg Type
                                switch (rule.type) {
                                    case 'id':
                                        {
                                            if (arg.replace(/([\w\-\.]+)/g, '') != '') {
                                                tellPlayer(player, errpref + _MSG["argNotValid"].fill({
                                                    "argName": rulename,
                                                    "allowed": "A-Za-z0-9_-:D"
                                                }) + errsuff);
                                                return false;
                                            }
                                            //Run case 'string'
                                        }
                                    case 'string':
                                        {
                                            if (arg.replace(/([\w\-\.]+)/g, '') != '') {
                                                tellPlayer(player, errpref + _MSG["argNotValid"].fill({
                                                    "argName": rulename,
                                                    "allowed": "&cA-Za-z0-9_-"
                                                }) + errsuff);
                                                return false;
                                            }
                                            if ('minlen' in rule) {
                                                if (arg.toString().length < rule.minlen) {
                                                    tellPlayer(player, errpref + "&c'" + rulename + "' is too short! (Min. " + rule.minlen + " characters)" + errsuff);
                                                    return false;
                                                }
                                            }
                                            if ('maxlen' in rule) {
                                                if (arg.toString().length < rule.maxlen) {
                                                    tellPlayer(player, errpref + "&c'" + rulename + "' is too long! (Min. " + rule.minlen + " characters)" + errsuff);
                                                    return false;
                                                }
                                            }
                                            if ("noColor" in rule) {
                                                if (rule.noColor) {
                                                    if (escCcs(arg.toString()) != arg.toString()) {
                                                        tellPlayer(player, errpref + "&c'" + rulename + "' cannot contain color coding!" + errsuff);
                                                        return false;
                                                    }
                                                }
                                            }
                                            break;
                                        }
                                    case 'enum':
                                        {
                                            if ("values" in rule) {
                                                if (rule.values.indexOf(arg) == -1) {
                                                    tellPlayer(player, "&c'" + rulename + "' must be one of the following: " + rule.values.join(", "));
                                                    return false;
                                                }
                                            }
                                            break;
                                        }
                                    case 'currency':
                                    case 'time':
                                    case 'number':
                                        {
                                            var num = NaN;
                                            if (rule.type == 'number') {
                                                num = parseFloat(arg);
                                            } else if (rule.type == 'currency') {
                                                num = getCoinAmount(arg);
                                            } else {
                                                num = getStringTime(arg);
                                            }

                                            if (isNaN(num)) {
                                                tellPlayer(player, errpref + "&c'" + rulename + "' is not a number!" + errsuff);
                                                return false;
                                            }
                                            if ('max' in rule) {
                                                if (num > rule.max) {
                                                    var rmax = rule.max;
                                                    if (rule.type == 'currency') {
                                                        rmax = getAmountCoin(rule.max);
                                                    } else if (rule.type == 'time') {
                                                        rmax = getTimeString(rule.max);
                                                    }
                                                    tellPlayer(player, errpref + "&c'" + rulename + "' cannot be greater than " + rmax + errsuff);
                                                    return false;
                                                }
                                            }
                                            if ('min' in rule) {
                                                if (num < rule.min) {
                                                    var rmin = rule.min;
                                                    if (rule.type == 'currency') {
                                                        rmin = getAmountCoin(rule.min);
                                                    } else if (rule.type == 'time') {
                                                        rmin = getTimeString(rule.min);
                                                    }
                                                    tellPlayer(player, errpref + "&c'" + rulename + "' cannot be less than " + rmin + errsuff);
                                                    return false;
                                                }
                                            }
                                        }
                                    case 'datahandler':
                                        {
                                            if ('datatype' in rule) {
                                                var dh = new DataHandler(rule.datatype, arg);
                                                if ('exists' in rule) {
                                                    var exists = dh.exists(data);
                                                    if (rule.exists && !exists) {
                                                        //Hasto exists but does not
                                                        tellPlayer(player, errpref + "&c" + dh.type.rangeUpper(0, 1) + " '" + dh.name + "' does not exist!" + errsuff);
                                                        return false;
                                                    }
                                                    if (!rule.exists && exists) {
                                                        //Has not to exists but does
                                                        tellPlayer(player, errpref + "&c" + dh.type.rangeUpper(0, 1) + " '" + dh.name + "' already exists!" + errsuff);
                                                        return false;
                                                    }
                                                }
                                            }
                                            break;
                                        }
                                    case 'color':
                                        {
                                            if (objArray(_RAWCOLORS).indexOf(arg) == -1) {
                                                tellPlayer(player, errpref + "&cColor must be one of the following: " + objArray(_RAWCOLORS).join(', ') + '!' + errsuff);
                                                return false;
                                            }
                                            break;
                                        }
                                    case 'coloreffect':
                                        {
                                            if (objArray(_RAWEFFECTS).indexOf(arg) == -1) {
                                                tellPlayer(player, errpref + "&cChat effects must be one of the following: \n" + objArray(_RAWEFFECTS).join("\n") + errsuff);
                                                return false;
                                            }
                                            break;
                                        }
                                    case 'attribute':
                                        {
                                            if (_ITEMATTR.indexOf(arg) == -1) {
                                                tellPlayer(player, errpref + "&cItem attributes must be one of these: \n" + _ITEMATTR.join("\n") + errsuff);
                                                return false;
                                            }
                                            break;
                                        }
                                    case 'bool':
                                        {
                                            if (['true', 'false'].indexOf(arg) == -1) {
                                                tellPlayer(player, errpref + "&c" + rulename.rangeUpper(0, 1) + " must be true or false!" + errsuff);
                                                return false;
                                            }
                                            break;
                                        }
                                }

                            }

                        }
                    }

                    return (cmd.callback(player, args, data, cmd.payload) || false);
                } else {
                    tellPlayer(player, "&cYou don't have permission to this command!");
                    return false;
                }
            }
        }
    }
    //No valid command given
    var usg = [];
    var aa = str.split(" ");

    while (aa.length > 0) {
        var saa = aa.join(" ");
        if (usg.length == 0) {
            for(var c in _COMMANDS) {
var cmd = _COMMANDS[c];
                if (occurrences(cmd.usage, saa) > 0) {
                    var lcp = new Permission(cmd.perm);
                    lcp.load(data);
                    if (lcp.permits(player.getName(), sb, data)) {
                        usg.push(cmd.usage);
                    }
                }
            }
        }
        aa.splice(-1, 1);
    }

    if (usg.length > 0) {
        var helpText = "&e<argument> &6means that it is required\n" +
            "&e[argument] &6means that it is optional\n" +
            "&e<...argument] &6means that you can provide multiple, but $nat least one$r\n" +
            "&e[...argument] &6means that you can provide multiple, or nothing.\n\n" +
            "&cClick on a command listed below, to save yourself some typing.";
        tellPlayer(player, "&a&lDid you mean?: &5[Help]{*|show_text:" + helpText.replace(/&/g, '$') + "}&r");
        for (var u in usg) {
            tellPlayer(player, "&e - &c" + usg[u] + "{suggest_command:" + getCommandNoArg(usg[u]) + "}");
        }
    } else {
        tellPlayer(player, "&cCould not find this command!\nDo &c&n!help or click here{run_command:!help}&c to see available commands.");
    }



    return false;

}



//Register commands

registerXCommands([
    ['!config reload', function(pl, args, data) {
        reloadConfiguration();
        tellPlayer(pl, "&aReloaded CustomServerTools configuration.");
    }, 'config.reload'],
]);



registerDataHandler("player", Player);

function Player(name) {


    DataHandler.apply(this, ['player', name]);

    this.addData({
        "lastPayed": 0,
        "pay": 0,
        "payTime": getStringTime('20min'),
        "firstLoan": true,
        "maxJobs": 2,
        "maxHomes": 2,
        "homes": {},
        "defaultHome": null,
        "jobs": {},
        "inventories": [],
        "emotes": [],
        "chatcolors": [], //Unlockables for color coding
        "chatcolor": null, //Default chatcolor (NOT FOR UNLOCKS)
        "badges": [],
        "showbadges": [],
        "chateffect": null,
        "firstLogin": new Date().getTime(),
        "lastLogin": 0,
        "color": null,
        "UUID": null,
        "money": 0,
        "meta": {},
        "backPos": null
    });

    this.dateData([
        'lastPayed', 'firstLogin', 'lastLogin'
    ]);
    this.timeData([
        'payTime',
    ]);

    this.moneyData([
        'money'
    ]);


    for(var v in VIRTUAL_CURRENCIES) {
var crncy = VIRTUAL_CURRENCIES[v];
        this.data[crncy.name] = crncy.default || 0;
    }

    this.registerBackPos = function(pos) {
        this.data.backPos = {
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };
        return this;
    };
    this.sync = function(ipl) {
        this.data.UUID = ipl.getUUID();
        this.name = ipl.getName();
        return this;
    };
    this.getTeamName = function(sb) {
        var t = sb.getPlayerTeam(this.name);
        if (t != null) {
            return t.getDisplayName();
        } else if (this.data.title != null) {
            return this.data.title;
        }

        return "";
    };
    this.getPlayerColor = function(sb) {
        var t = sb.getPlayerTeam(this.name);
        var ccol = 'white';
        if (this.data.color != null) {
            ccol = this.data.color

        } else if (t != null) {
            ccol = t.getColor();
        }
        return ccol;
    };
    this.getChatColorPref = function(sb, data) {
        var pref = '';
        var prefeff = '';
        var t = sb.getPlayerTeam(this.name);
        if (t != null) {
            var td = new Team(t.getName()).init(data);
            if (td.data.chatcolor != null) {
                pref = '&' + getColorId(td.data.chatcolor);
            }
            if (td.data.chateffect != null) {
                prefeff = '&' + getColorId(td.data.chateffect);
            }
        }

        if (this.data.chatcolor != null) {
            pref = '&' + getColorId(this.data.chatcolor);
        }


        if (this.data.chateffect != null) {
            prefeff = '&' + getColorId(this.data.chateffect);
        }
        return pref + prefeff;
    };


    this.getNameTag = function(sb, prefix, namesuff, teamsuff, ccChar, data) {
	if(typeof(data) == typeof(undefined) || data === null) { data = null; }
        var t = sb.getPlayerTeam(this.name);
        var dc = ccChar || '&';
        var ccol = '';
        var ctm = '';
        if (this.data.color != null) {
            var cId = getColorId(this.data.color);
            ccol = dc + cId;
        } else if (t != null) {
            ccol = dc + getColorId(t.getColor());
        }

        if (t != null) {
            ctm = ccol + dc + 'o' + t.getDisplayName() + ' ';
        }

        var badgestr = "";
        var badges = data != null ? this.getBadges(data) : [];
        var st;
        for(var i in badges) {
var badge = badges[i];
            if (i < 3) {
                st = (badge.data.displayName + "&r\n" + badge.data.desc).replaceAll("&", "$");
                badgestr += ":" + badge.data.emote + ":{*|show_text:" + st + "}&r";
            }
        }

        return ccol + dc + 'l[' + ccol + ctm + (teamsuff || '') + dc + 'r' + badgestr + ccol + this.name + (namesuff || '') + ccol + dc + 'l' + ']' + (prefix || '') + dc + 'r';
    };
    this.getBadges = function(data) {
        var badges = new Badge().getAllDataEntries(data);
        var retbadges = [];
        for(var i in badges) {
var badge = badges[i];
            if (this.data.badges.indexOf(badge.name) > -1) {
                //has badge
                retbadges.push(badge);
            }
        }

        return retbadges;
    };
    this.delJob = function(name) {
        if (this.hasJob(name)) {
            delete this.data.jobs[name];
        }
        return this;
    };
    this.getJob = function(name) {
        if (this.hasJob(name)) {
            return this.data.jobs[name];
        }
        return null;
    };
    this.getJobs = function(data) {
        var jobs = [];
        for(var i in this.data.jobs) {
var job = this.data.jobs[i];
            var pjob = new Job(i);
            if (pjob.load(data)) {
                jobs.push(pjob);
            }
        }
        return jobs;
    };
    this.getJobCount = function() {
        return Object.keys(this.data.jobs).length;
    };
    this.addJob = function(name) {
        this.data.jobs[name] = {
            "lastPayed": 0
        };
        return this;
    };
    this.hasJob = function(name) {
        return Object.keys(this.data.jobs).indexOf(name) > -1;
    };
    this.hasMaxJobs = function() {
        return (this.data.maxJobs != -1 && this.getJobCount() >= this.getMaxJobs());
    };
    this.getMaxJobs = function(sb) {
        //check this.getMaxHomes()
        return this.data.maxJobs;
    };
    this.addHome = function(name, x, y, z) {
        this.data.homes[name] = {
            x: x,
            y: y,
            z: z,
        };
        return this;
    };
    this.delHome = function(name) {
        if (this.data.homes.hasOwnProperty(name)) {
            delete this.data.homes[name];
        }
        return this;
    };
    this.hasHome = function(name) {
        return (this.data.homes.hasOwnProperty(name));
    };
    this.getMaxHomes = function(sb) {
        //WILL be edited later for handling the desision maxHome setting in teams
        return this.data.maxHomes;
    };

    this.getChats = function(data) {
        var chats = [];
        var dkeys = data.getKeys();
        for(var d in dkeys) {
var dkey = dkeys[d];
            if (dkey.cmatch(/chatchannel_([\w]+)/g) > 0) {
                var cc = new ChatChannel(dkey.replace(/chatchannel_([\w]+)/g, "$1"));
                if (cc.load(data)) {
                    if (cc.data.players.indexOf(this.name) > -1) {
                        chats.push(cc);
                    }
                }
            }
        }

        return chats;
    }
    this.getAllowedColors = function(data, sb) {
        var ac = [];
        //Check individual colors
        for(var i in _RAWCOLORS) {
var rc = _RAWCOLORS[i];
            var cp = new Permission(getColorPermId(getColorId(rc))).init(data);
            if (cp.permits(this.name, sb, data, true, false)) {
                ac.push(getColorId(rc));
            }
        }
        for(var i in _RAWEFFECTS) {
var rc = _RAWEFFECTS[i];
            var cp = new Permission(getColorPermId(getColorId(rc))).init(data);
            if (cp.permits(this.name, sb, data, true, false)) {
                ac.push(getColorId(rc));
            }
        }

        return ac;
    };
    this.canCreateCommandText = function(data, sb) {
        return new Permission('chat.command').init(data).permits(this.name, sb, data);
    };
    this.getBounty = function(sb) {
        var sbo = sb.getObjective("bounty");
        if (sbo != null) {
            var sbs = sbo.getScore(this.name);
            if (sbs != null) {
                return sbs.getValue();
            }
        }
        return 0;
    };


    this.getInventory = function(name) {
        for(var invName in this.data.inventories) {
var inv = this.data.inventories[invName];
            if (inv[0] == name) return inv[1];
        }
        return;
    };
    this.removeInventory = function(name) {
        for (var invName in this.data.inventories) {
            this.data.inventories.splice(invName, 1);
            return true;
        }
        return false;
    };
    this.hasEmote = function(name, sb, data) { //Checks if player has emote
        var em = new Emote(name).init(data, false);
        return (this.data.emotes.indexOf(name) > -1 ||
            em.getPermission().init(data, false).permits(this.name, sb, data) ||
            em.data.default
        );
    };

    this.getAllowedEmotes = function(sb, data) {
        var ems = [];
        for(var c in CHAT_EMOTES) {
var ce = CHAT_EMOTES[c];
            var ec = new Emote(c);
            ec.load(data);
            if (this.hasEmote(ec.name, sb, data)) {
                ems.push(ec.name);
            }
        }
        return ems;
    };

    this.getBanks = function(data) {
        var banks = [];
        var allBanks = new Bank().getAllDataEntries(data);

        for(var i in allBanks) {
var checkBank = allBanks[i];
            if (checkBank.canSee(this.name)) {
                banks.push(checkBank);
            }
        }

        return banks;
    }
}

registerDataHandler("permission", Permission);

function Permission(name) {
    DataHandler.apply(this, ['permission', name]);

    this.addData({
        "enabled": true,
        "teams": CONFIG_SERVER.DEFAULT_PERM_TEAMS,
        "players": [],
        "jobs": [],
        "meta": {}
    });

    this.set = function(key, val) {
        this.data[key] = val;
        return this;
    };

    this.addTeams = function(teams) {
        if (typeof(teams) == 'string') { teams = [teams]; }
        for(var t in teams) {
var team = teams[t];
            var teamname = team;
            if (this.data.teams.indexOf(teamname) == -1) {
                this.data.teams.push(teamname);
            }
        }

        return this;
    };
    this.removeTeams = function(teams) {
        if (typeof(teams) == 'string') {
            teams = [teams];
        }

        var nteams = [];
        for(var t in this.data.teams) {
var team = this.data.teams[t];
            if (teams.indexOf(team) == -1) {
                nteams.push(team);
            }
        }
        this.data.teams = nteams;
        return this;
    };
    this.addPlayers = function(players) {
        if (typeof(players) == 'string') { players = [players]; }
        for(var p in players) {
var player = players[p];
            if (this.data.players.indexOf(player) == -1) {
                this.data.players.push(player);
            }
        }

        return this;
    };
    this.removePlayers = function(players) {
        if (typeof(players) == 'string') { players = [players]; }
        var nplayers = [];
        for(var p in this.data.players) {
var player = this.data.players[p];
            if (players.indexOf(player) == -1) {
                nplayers.push(player);
            }
        }
        this.data.players = nplayers;
        return this;
    };
    this.permitsPlayer = function(pl, listenToDisabled) {
	if(typeof(listenToDisabled) == typeof(undefined) || listenToDisabled === null) { listenToDisabled = true; }
        return this.permits(pl.getName(), pl.world.scoreboard, pl.world.storeddata);
    };

    this.permits = function(player, sb, data, listenToDisabled) {
	if(typeof(listenToDisabled) == typeof(undefined) || listenToDisabled === null) { listenToDisabled = true; }
        ///String player
        ///IScoreboard sb
        ///IData data
        var team = sb.getPlayerTeam(player);
        var permitted = false;
        var p = new Player(player);
        p.load(data);
        //Check enabled
        if (!this.data.enabled && listenToDisabled) { return true; }

        if (this.name != "__ALL__") {
            if (new Permission("__ALL__").init(data, true).permits(player, sb, data, false)) {
                return true;
            }
        }


        //Check team
        if (team != null) {
            if (this.data.teams.indexOf(team.getName()) != -1) {
                permitted = true;
            }
        }
        //Check player
        if (this.data.players.indexOf(player) != -1) {
            permitted = true;
        }

        //Check jobs
        /*
        var pjobs = p.getJobs(data);
        for(var p in pjobs) {
var pjob = pjobs[p];
        	if(this.data.jobs.indexOf(pjob.name) != -1) {
        		permitted = true;
        	}
        }*/

        //Check parents
        var ppar = getParentPerms(this.name || "", data);
        for(var p in ppar) {
var par = ppar[p];
            if (par.permits(player, sb, data, false)) {
                permitted = true;
                break;
            }
        }



        return permitted;
    };
}

function getParentPerms(name, data) {
    var ps = (name + "").split(".");
    var par = [];
    var cs = "";
    for (var i = 0; i < ps.length; i++) {
        if (i < ps.length - 1) {
            cs += (cs != "" ? "." : "") + ps[i];
            if (new Permission(cs).exists(data)) {
                par.push(new Permission(cs).init(data));
            }
        }
    }
    return par;

}



//
function worldOut(str) {
    API.getIWorld(0).broadcast(strf(str));
}


//Parses JSON with comments and trailing comma's to json objects
function cson_parse(cson_string) {
    var rgx_comments = /\/(?:\*{2,}\s[\s\S]+?|\*[^\*]+?)\*\/|([\s;])+\/\/.*$/gm;
    var rgx_commas = /,+\s*(\}|\])/g;
    //print("CSON::: "+cson_string.replace(rgx_comments, '').replace(rgx_commas, '$1').replace(/[\n\t]/g, ""));
    return JSON.parse((cson_string.replace(rgx_comments, '').replace(rgx_commas, '$1')));
}







//

//Initialize PLugin Folder
var PLUGIN_FOLDER = CONFIG_SERVER.PLUGIN_FOLDER||"CustomServerTools/plugins";
var PLUGIN_LIST = [];

var PluginAPI = {
    Plugins: {
        get: function(name){
            for(var i in PLUGIN_LIST) {
var _plugin = PLUGIN_LIST[i];

                if(_plugin.id.toString() === name.toString()) {
                    return _plugin;
                }
            }
            return null;
        },
        list: function(){
            var ids = [];
            for(var i in PLUGIN_LIST) {
var plugin = PLUGIN_LIST[i];
                ids.push(plugin);
            }
            return ids;
        },
        export: function(key, value){
            PluginAPI._exports[key] = value;
        },
        import: function(key){
            return PluginAPI._exports[key];
        },
        _exports: {},
    },
    DataHandlers: {
        implement: function(datahandlername, implementationFunc) {
            if(!(datahandlername in PluginAPI.DataHandlers.implementFuncs)) {
                PluginAPI.DataHandlers.implementFuncs[datahandlername] = [];
            }
            PluginAPI.DataHandlers.implementFuncs[datahandlername].push(implementationFunc);
        },
        implementFuncs: {},
        run: function(dhname, t) {
            if(dhname in PluginAPI.DataHandlers.implementFuncs) {
                var imf = PluginAPI.DataHandlers.implementFuncs[dhname];
                for(var i in imf) {
var im = imf[i];
                    im.apply(t, []);
                }
            }
        }
    },
    Players: {
        on: function(hook, func){
            if(!(hook in PluginAPI.Players.hookFns)) {
                PluginAPI.Players.hookFns[hook] = [];
            }

            PluginAPI.Players.hookFns[hook].push(func)
        },
        run: function(hook, args){
            if(Object.keys(PluginAPI.Players.hookFns).indexOf(hook) > -1) {
                for(var i in PluginAPI.Players.hookFns[hook]) {
var hookFn = PluginAPI.Players.hookFns[hook][i];
                    hookFn.apply(null, args);
                }
            }
        },
        hookFns: {},
    },
};




registerXCommands([
    ['!plugins', function(pl, args, data){
        var output = getTitleBar("Plugin List")+"\n&dHover plugin name for more info\n&a";
        for(var p in PLUGIN_LIST) {
var plugin = PLUGIN_LIST[p];
            var pluginInfo = "$6$lName: $r$e{PluginName}\n$r$6$lID: $r$e{PluginId}\n$r$6$lAuthor: $r$e{PluginAuthor}\n$r$6$lVersion: $r$e{PluginVersion}\n\n$r$e{PluginDesc}$r".fill({
                "PluginId": plugin.id,
                "PluginName": plugin.name,
                "PluginVersion": plugin.version,
                "PluginDesc": plugin.description||"",
                "PluginAuthor": plugin.author||"No author defined",
            });
            output += plugin.name+"{*|show_text:"+pluginInfo+"}&a";
            if(p < PLUGIN_LIST.length-1) {
                output += ", ";
            }
        }
        tellPlayer(pl, output);
        return true;
    }, 'plugins.list'],
    ['!plugin reload', function(pl, args, data){
        if(reloadPluginsFromDisk()) {
            tellPlayer(pl, "&r[&eCSTPluginLoader{*|show_text:$eCustomServerTools PluginLoader}&r] &aLoaded &c{PluginCount} &aplugins! &2[Plugin List]{run_command:!plugins|show_text:$aClick to see plugins or do $o$a!plugins}&r".fill({
                "PluginCount": PLUGIN_LIST.length
            }));
        }
    }, 'plugins.reload'],
]);



//1 if v1 > v2
//0 if same
//-1 if v1 < v2
function compareVersion(v1, v2, options) {
    var lexicographical = options && options.lexicographical,
        zeroExtend = options && options.zeroExtend,
        v1parts = v1.split('.'),
        v2parts = v2.split('.');

    function isValidPart(x) {
        return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
    }

    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
        return NaN;
    }

    if (zeroExtend) {
        while (v1parts.length < v2parts.length) v1parts.push("0");
        while (v2parts.length < v1parts.length) v2parts.push("0");
    }

    if (!lexicographical) {
        v1parts = v1parts.map(Number);
        v2parts = v2parts.map(Number);
    }

    for (var i = 0; i < v1parts.length; ++i) {
        if (v2parts.length == i) {
            return 1;
        }

        if (v1parts[i] == v2parts[i]) {
            continue;
        }
        else if (v1parts[i] > v2parts[i]) {
            return 1;
        }
        else {
            return -1;
        }
    }

    if (v1parts.length != v2parts.length) {
        return -1;
    }

    return 0;
}


















































function reloadPluginsFromDisk() {
    PLUGIN_LIST = [];
    PluginAPI.Players.hookFns = {};

    if(!(new File(PLUGIN_FOLDER).exists())) {
        mkPath(PLUGIN_FOLDER);
    }




    //Load plugins
    var pluginDirs = new File(PLUGIN_FOLDER).listFiles();
    var pluginsToRun = [];
    //Loop plugin directories
    for(var p in pluginDirs) {
var pluginDir = pluginDirs[p];
        if(pluginDir.isDirectory()) {
            var pluginFiles = pluginDir.listFiles();
            var loadPlugin = null;
            for(var pf in pluginFiles) {
var pluginFile = pluginFiles[pf];
                //get config file
                if(pluginFile.getName() == "plugin.json") {
                    try {
                        loadPlugin = cson_parse(readFileAsString(pluginFile.getPath()));
                        loadPlugin['DIR'] = pluginDir.getPath();
                        //Load JS files
                        for(var lf in loadPlugin.files) {
var lfilename = loadPlugin.files[lf];
                            var lfilepath = pluginDir.getPath()+"/"+lfilename;
                            var lfile = new File(lfilepath);
                            if(lfile.exists()) {
                                //loadPlugin.fileFuncs[lfilepath] = (loadPlugin.fileFuncs[lfilepath]||[]).push(readFileAsString(lfilepath));



                                var fileScript = readFileAsString(lfilepath)
                                var fileFunc = new Function("SETTINGS", "PLUGIN", fileScript);
                                pluginsToRun.push({
                                    "func": fileFunc,
                                    "plugin": loadPlugin
                                })

                            }
                        }

                    } catch (exc) {
                        handleError(exc);
                    }



                    break;
                }
            }
            if(loadPlugin != null) {
                PLUGIN_LIST.push(loadPlugin);
            } else {
                var errtxt = "&cError loading plugin! &n&c[info]{*|show_text:$c{PluginDir} has no plugin.json!}".fill({
                    "PluginDir": pluginDir.getPath()
                });
                executeCommandGlobal("/tellraw @a "+strf(errtxt));
                return false;
            }
        }
    }

    for(var i in pluginsToRun) {
var runPlugin = pluginsToRun[i];
        //Check requirements
        var canRun = true;
        var req = (runPlugin.plugin.required||{});
        var errtxt = "";
        if(Object.keys(req).length > 0) {
            for(var reqid in req) {
var minver = req[reqid];
                var checkPlugin = PluginAPI.Plugins.get(reqid);
                if(checkPlugin != null) {

                    if(compareVersion(checkPlugin.version, minver) == -1) {
                        errtxt += "&cError loading plugin '"+runPlugin.plugin.id+"' &4[Info]{*|show_text:{INFO}}&r\n".fill({
                            "INFO": ("&cToo low version of plugin '"+reqid+"' installed! Current: &l"+checkPlugin.version+"&r&c Required: &l"+minver).replaceAll("&", "")
                        });
                        canRun = false;
                    }
                } else {
                    errtxt += "&cError loading plugin '"+runPlugin.plugin.id+"' &4[Info]{*|show_text:{INFO}}&r\n".fill({
                        "INFO": ("&cThis plugin requires &o"+reqid+"&r&c to be installed!").replaceAll("&", "")
                    });
                    canRun = false;
                }
            }


        }

        if(canRun) {
            try {
                //execute plugins
                runPlugin.func(runPlugin.plugin.settings||{}, runPlugin.plugin);
            } catch(exc) {
                handleError(exc);
            }
        } else {
            executeCommandGlobal("/tellraw @a "+strf(errtxt));
        }
    }

    return true;
}

function compare(fval, operator, sval) {
    switch (operator) {
        case '==':
            return fval == sval;
            break;
        case '===':
            return fval === sval;
            break;
        case '!=':
            return fval != sval;
            break;
        case '!==':
            return fval !== sval;
            break;
        case '>':
            return fval > sval;
            break;
        case '<':
            return fval < sval;
            break;
        case '>=':
            return fval >= sval;
            break;
        case '<=':
            return fval <= sval;
            break;

    }

    return false;
}




function dataHandlerQuery(type, items) {
    var query = {
        _items: items,
        _limit: -1,
        _where: [],
    };

    query.dump = function(player) {

        var results = query.get();
        var moreResults = 0;
        var resultCount = 0;

        var queryInfo = '';

        for(var i in query._where) {
var qw = query._where[i];
            queryInfo += '&awhere &e' + qw[0] + ' &6' + qw[1] + ' &c' + qw[2] + '\n';
        }

        tellPlayer(player, '&5&l#Query Dump');
        tellPlayer(player, '&d#[Query Info]{*|show_text:' + queryInfo.replaceAll('&', '$') + '}&r');
        for(var i in results) {
var result = results[i];
            if (parseInt(i) > 14) {
                moreResults++;
                continue;
            }

            result.dump.apply(result, arguments);
            resultCount++;
        }

        tellPlayer(player, '&3#[&b ' + resultCount + ' result(s). &3]');

        if (moreResults > 0) {
            tellPlayer(player, '&3...&b' + moreResults + ' more results&3...');
        }

        return this;
    };

    query.whereMoney = function(name, operator, amount) {
        if (typeof amount === 'undefined') {
            amount = operator;
            operator = '==';
        }
        amount = getCoinAmount(amount);

        return query.where(name, operator, amount);
    };

    query.whereTime = function(name, operator, time) {
        if (typeof time === 'undefined') {
            time = operator;
            operator = '==';
        }

        time = getStringTime(time);

        return query.where(name, operator, amount);
    };



    query.where = function(name, operator, value) {
        if (typeof name === 'function') {
            query._items = query._items.filter(name);
        } else {
            if (typeof value === 'undefined') {
                value = operator;
                operator = '==';
            }

            query._where.push([name, operator, value]);

            query._items = query._items.filter(function(item) {
                return compare((getObjectProp(item, 'data.' + name) || getObjectProp(item, name)), operator, value);
            });
        }

        return query;
    };

    query.whereCount = function(name, operator, value) {
        if (typeof value === 'undefined') {
            value = operator;
            operator = '==';
        }

        query._where.push([name, operator, value]);

        query._items = query._items.filter(function(item) {
            return compare((getObjectProp(item, 'data.' + name) || getObjectProp(item, name) || []).length, operator, value);
        });

        return query;
    }

    query.whereContains = function(key, value, caseSensitive) {
	if(typeof(caseSensitive) == typeof(undefined) || caseSensitive === null) { caseSensitive = true; }
        if (!isArray(value)) {
            value = [value];
        }
        query._where.push([key, 'contains', value]);

        query._items = query._items.filter(function(item) {
            var contains = false;
            var haystack = (getObjectProp(item, 'data.' + key) || getObjectProp(item, key)).toString();
            for(var v in value) {
var val = value[v];
                if (!caseSensitive) {
                    if (typeof haystack === 'string') {
                        haystack = haystack.toLowerCase();
                    }
                    val = val.toLowerCase();
                }


                if (haystack.indexOf(val) > -1) {
                    contains = true;
                }

            }

            return contains;
        });

        return query;
    };

    query.whereNull = function(name) {
        return query.where(name, '===', null);
    };

    query.whereNotNull = function(name) {
        return query.where(name, '!==', null)
    }

    query.shuffle = function() {
        query._items = array_shuffle(query._items);
        return query;
    };

    query.limit = function(amount) {
        query._items.splice(amount, query._items.length);
        return query;
    };

    query.first = function() {
        return query._items[0] || null;
    }

    query.last = function() {
        return query._items[query._items.length - 1] || null;
    }

    query.skip = function(amount) {
        query._items.splice(0, amount);
        return query;
    };

    query.sortBy = function() {
        for(var i in arguments) {
var key = arguments[i];
            query._items.sort(function(a, b) {
                var ak = getObjectProp(a, key) || getObjectProp(a, 'data.' + key);
                var bk = getObjectProp(b, key) || getObjectProp(b, 'data.' + key);

                if (ak == null || bk == null) { return 0; }
                if (ak < bk) return -1;
                if (ak > bk) return 1;

                return 0;
            });
        }

        return query;
    };

    query.sortByDesc = function(key) {
        query._items.sort(function(a, b) {
            var ak = getObjectProp(a, key) || getObjectProp(a, 'data.' + key);
            var bk = getObjectProp(b, key) || getObjectProp(b, 'data.' + key);

            if (ak == null || bk == null) { return 0; }
            if (ak < bk) return -1;
            if (ak > bk) return 1;

            return 0;
        });

        query._items.reverse();

        return query;
    };

    query.get = function() {
        var items = query._items.concat([]);
        if (query._limit > -1) {
            items.splice(query._limit, query._items.length);
        }

        return items;
    };

    Object.defineProperty(query, 'count', {
        get: function() {
            return query._items.length;
        }
    });


    Object.defineProperty(query, 'each', {
        get: function() {
            return dataHandlerCaller(type, query._items);
        }
    });

    return query;
};

function dataHandlerCaller(type, items) {
    var dht = getDataHandler(type);
    var props = [];
    var mockDataHandler = new dht('__mock__');

    var caller = {
        _items: items
    };

    for(var prop in mockDataHandler) {
var val = mockDataHandler[prop];
        if (typeof val === 'function') {
            caller[prop] = (function(prop, mockDataHandler, val) {
                return function() {
                    for(var i in caller._items) {
var item = caller._items[i];
                        item[prop].apply(item, arguments);
                    }

                    return caller;
                };
            })(prop, mockDataHandler, val);
        }
    }

    return caller;
}
var _UNIQIDS = [];

function uniqid(length) {
	if(typeof(length) == typeof(undefined) || length === null) { length = 7; }
    var _CHARSET = "01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var id;
    do {
        id = "";

        for (var i = 0; i < length; i++) {
            var index = rrandom_range(0, _CHARSET.length - 1);
            id += _CHARSET.slice(index, index + 1).toString();
        }
    } while (_UNIQIDS.indexOf(id) > -1);


    return id;
}
//Superfunction (extendable)
//Used to save function data object.
function DataHandler(type, name) {
    this.type = type;
    this.name = name;
    this.data = this.data || {};
    this.removeFns = this.removeFns || [];
    this.loadFns = this.loadFns || [];
    this.loadedFns = this.loadedFns || [];
    this.saveFns = this.saveFns || [];
    this.createFns = this.createFns || [];
    this._moneyData = [];
    this._timeData = [];
    this._dateData = [
        'created', 'updated'
    ];

    this.dkeyrgx = new RegExp(this.type + '_([\\w.\-]+)', 'g');


    this.moneyData = function(props) {
        this._moneyData = this._moneyData.concat(props);
        return this;
    };

    this.timeData = function(props) {
        this._timeData = this._timeData.concat(props);
        return this;
    };
    this.dateData = function(props) {
        this._dateData = this._dateData.concat(props);
        return this;
    };


    Object.defineProperty(this.data, 'name', {
        get: function() {
            return this.name;
        },
    });

    //Gets all data IDS
    this.getAllDataIds = function(data, includeType) {
	if(typeof(includeType) == typeof(undefined) || includeType === null) { includeType = false; }
        var dkeys = data.getKeys();
        var ids = [];
        for(var d in dkeys) {
var dkey = dkeys[d];
            if (dkey.cmatch(this.dkeyrgx) > 0) {
                ids.push(includeType ? dkey : dkey.replace(this.dkeyrgx, '$1'));
            }
        }

        return ids;
    };

    this.addData = function(dataObj) {
        this.data = objMerge(this.data, dataObj);
    };

    this.getAllDataEntries = function(data) {
        var ids = this.getAllDataIds(data, true);
        var de = [];

        for(var i in ids) {
var id = ids[i];
            if (DataHandler.cache[id]) {
                de.push(DataHandler.cache[id]);
                continue;
            }

            var dht = getDataHandler(this.type);
            var newDht = new dht(id.replace(this.dkeyrgx, '$1')).init(data);
            de.push(newDht);
            DataHandler.cache[id] = newDht;
        }

        return de;
    };

    this.query = function(data) {
        return dataHandlerQuery(this.type, this.getAllDataEntries(data));
    };

    this.dumpdata = function(player, prop) {
        tellPlayer(player, this._getdump(player, prop));
    };

    this._getdump = function(player, prop) {
	if(typeof(prop) == typeof(undefined) || prop === null) { prop = ''; }
        var propTypes = {};
        for(var i in this._moneyData) {
var moneyProp = this._moneyData[i];
            propTypes[moneyProp] = 'money';
        }
        for(var i in this._timeData) {
var timeProp = this._timeData[i];
            propTypes[timeProp] = 'time';
        }
        for(var i in this._dateData) {
var dateProp = this._dateData[i];
            propTypes[dateProp] = 'date';
        }
        return formatObj(getObjectProp(this.data, prop), 1, 3, -1, propTypes, null, function() {
            this.maxLoop = 2;
        });
    }

    this.dump = function(player) {
        var dumpInfo = ' === &2&lDUMP&r === \n' +
            '&6&lType: &c' + this.type + '\n' +
            '&6&lName: &e' + this.name + '\n\n' +
            '&r === &2&lPROPERTIES&r === \n';

        var allowed = [];
        var hidden = [];

        for (var i in arguments) {
            if (parseInt(i) == 0) {
                continue;
            }
            var prop = arguments[i];
            if (prop.substr(0, 1) == '*') {
                hidden.push(prop.substr(1, prop.length));
                continue;
            }

            if (Object.keys(this.data).indexOf(prop) == -1) {
                var val = getObjectProp(this.data, prop);
                dumpInfo += '&r - &a(' + typeof val + ')&d' + prop + '&d: &e' + formatObj(val, null, 2, 1) + '\n';
            }
            allowed.push(prop);

        }

        var shownProps = [];

        for(var prop in this.data) {
var val = this.data[prop];
            if (allowed.indexOf(prop) == -1 && allowed.length > 0) {
                continue;
            }
            if (hidden.indexOf(prop) > -1) {
                continue;
            }

            if (shownProps.length > 7) {
                continue;
            }

            shownProps.push(prop);

            var valType = typeof val;
            var showVal = formatObj(val, null, 2, 2);

            if (this._moneyData.indexOf(prop) > -1) {
                valType = 'money';
                showVal = '&r:money:&e' + getAmountCoin(val);
            }
            if (this._timeData.indexOf(prop) > -1) {
                valType = 'time';
                showVal = ':sun:' + getTimeString(val);
            }
            if (this._dateData.indexOf(prop) > -1) {
                valType = 'date';
                showVal = getDateString(val);
            }

            dumpInfo += '&r - &a(' + valType + ')&d' + prop + '&d: &e' + showVal + '\n';
        }

        var propDiff = Object.keys(this.data).length - shownProps.length;
        if (propDiff > 0 && allowed.length == 0) {
            dumpInfo += '&3Hiding ' + propDiff + ' more properties.\n&b' + Object.keys(this.data).filter(function(key) {
                return shownProps.indexOf(key) == -1;
            }).join(', ');
        }

        var output = '&3#&b(&c"' + this.type + '"&b) &e&o"' + this.name.substr(0, 16) + (this.name.length > 20 ? '...' : '') + '" &d[Read Dump]{*|show_text:' + dumpInfo.replaceAll('&', '$') + '}';

        tellPlayer(player, output);
        return this;
    }

    this.getDataId = function() {
        return this.type + '_' + this.name;
    }
    this.exists = function(data) {
        return data.get(this.getDataId()) != null;
    };
    this.save = function(data) {
        var now = new Date().getTime();
        if (!this.exists(data)) { //Run onCreate
            for(var i in this.createFns) {
var createFn = this.createFns[i];
                if (typeof(createFn) == 'function') {
                    createFn(this, data);
                }
            }
            this.data.created = now;
        }
        //Run onSave
        for(var i in this.saveFns) {
var saveFn = this.saveFns[i];
            if (typeof(saveFn) == 'function') {
                saveFn(this, data);
            }
        }
        this.data.updated = now;
        data.put(this.getDataId(), this.toJson());
        return this;
    };
    this.load = function(data) {
        if (this.exists(data)) {
            for(var i in this.loadFns) {
var loadFn = this.loadFns[i];
                if (typeof(loadFn) == 'function') { loadFn(this, data); }
            }
            var ndata = data.get(this.getDataId());
            this.data = objMerge(this.data, JSON.parse(ndata));
            for(var i in this.loadedFns) {
var loadedFn = this.loadedFns[i];
                if (typeof(loadedFn) == 'function') { loadedFn(this, data); }
            }
            return true;
        }
        return false;
    };
    this.remove = function(data) {
        for(var rf in this.removeFns) {
var removeFn = this.removeFns[rf];
            if (typeof(removeFn) == 'function') {
                removeFn(this, data);
            }
        }
        data.remove(this.getDataId());
        if (DataHandler.cache[this.getDataId()]) {
            delete DataHandler.cache[this.getDataId()];
        }
        return this;
    };
    this.onRemove = function(fn, args) { //When removed
        this.removeFns.push(fn, args || {});
        return this;
    };
    this.onLoad = function(fn, args) { //When gets loaded, before retrieving data
        this.loadFns.push(fn, args || {});
        return this;
    };
    this.onLoaded = function(fn, args) { //when loaded is complete
        this.loadedFns.push(fn, args || {});
        return this;
    };
    this.onSave = function(fn, args) { //Everytime when gets saved
        this.saveFns.push(fn, args || {});
        return this;
    };
    this.onCreate = function(fn, args) { //When gets saved but did not exists before (newly created)
        this.createFns.push(fn, args || {});
        return this;
    };
    this.init = function(data, createIfNotExists) {
	if(typeof(createIfNotExists) == typeof(undefined) || createIfNotExists === null) { createIfNotExists = true; }
        var self = this;
        if (DataHandler.cache[this.getDataId()]) {
            self = DataHandler.cache[this.getDataId()];
        }

        if (!self.exists(data) && createIfNotExists) {
            self.save(data);
        }
        self.load(data);

        return self;
    };
    this.set = function(key, value) {
        if (Object.keys(this.data).indexOf(key) > -1) {
            this.data[key] = value;
        }

        return this;
    };
    this.set = function(key, value) {
        if (Object.keys(this.data).indexOf(key) > -1) {
            this.data[key] = value;
        }

        return this;
    };
    this.setMoney = function(key, value) {
        return this.set(key, getCoinAmount(value));
    };

    this.setTime = function(key, value) {
        return this.set(key, getStringTime(value));
    };

    this.add = function(key, amount) {
        return this.set(key, this.data[key] + amount);
    };

    this.addMoney = function(key, amount) {
        return this.add(key, getCoinAmount(amount));
    };

    this.addTime = function(key, time) {
        return this.add(key, getStringTime(time));
    };



    this.sub = function(key, amount) {
        return this.set(key, this.data[key] - amount);
    }

    this.subMoney = function(key, amount) {
        return this.sub(key, getCoinAmount(amount));
    };

    this.subTime = function(key, time) {
        return this.sub(key, getStringTime(time));
    };


    this.toJson = function() {
        return JSON.stringify(this.data);
    };

    this.fill = function(data) {
        this.data = Object.assign(this.data, data);

        return this;
    };

    this.rename = function(name, data) {
        var clone = this.copy(name, data);

        this.remove(data);
        clone.save(data);

        return clone;
    };

    this.copy = function(name, data) {
        var clone = new this.constructor(name);

        clone.data = Object.assign(clone.data, this.data);

        return clone;
    }

    PluginAPI.DataHandlers.run(this.type, this);

    var now = new Date().getTime();

    this.addData({
        'created': now,
        'updated': now
    });
}
var _DHCacheKey = 'DataHandlerCache';
DataHandler.__proto__.cache = {};

var tempdata = API.getIWorld(0).tempdata;
if (!tempdata.has(_DHCacheKey)) {
    tempdata.put(_DHCacheKey, DataHandler.cache);
}


//Superfunction (extendable)
//Used to add permission requirements to datahandlers.
function Permittable(permDomain) {
	this.permDomain = permDomain||this.type;
	//Requires DataHandler
	this.getPermission = function(){
		return new Permission(this.getPermissionId());
	};
	this.getPermissionId = function(){
		return this.permDomain+'.'+this.name;
	};
	this.onRemove(function(self, data) {
		self.getPermission().remove(data); //Removes permission when DataHandler gets removed

	});
	this.onSave(function(self, data){
		var perm = self.getPermission();
		if(!perm.exists(data)) {
			//Create permission of permittable if not exists
			perm.save(data); //this will run Permission onSave functions
		}
	});
}


registerDataHandler("emote", Emote);

function Emote(name) {
    DataHandler.apply(this, ['emote', name]);
    Permittable.apply(this, ['emotes']);

    this.addData({
        "price": 0,
        "desc": "",
        "default": false, //If everyone has the emote by default
        "forSale": false, //If emote can be bought
        "hidden": false, //Will be hidden from !myEmotes, unless player has it, if forSale == true emote can still be bought via command
    });

    this.getCode = function() {
        return CHAT_EMOTES[this.name] || "?";
    };
}




function init(e) {
    var ndata = e.npc.getStoreddata();
    if (!ndata.has("GIVE_EMOTE")) {
        ndata.put("GIVE_EMOTE", "nether_star");
    }
}

function interact(e) {
    var data = e.npc.world.getStoreddata();
    var ndata = e.npc.getStoreddata();
    var sb = e.player.world.getScoreboard();
    var pl = e.player;
    var plo = new Player(pl.getName()).init(data);
    if (e.player.getGamemode() == 1 && e.player.isSneaking()) {
        var mItem = e.player.getMainhandItem();
        if (mItem.getName() == "minecraft:name_tag" && mItem.hasCustomName()) {
            if (Object.keys(CHAT_EMOTES).indexOf(mItem.getDisplayName()) > -1) {
                tellPlayer(pl, "&aSet give emote to &r:" + mItem.getDisplayName() + ":");
                ndata.put("GIVE_EMOTE", mItem.getDisplayName());
            } else {
                tellPlayer(pl, "&cEmote does not exists!");
            }
        }
        return true;
    }


    var giveEmote = ndata.get("GIVE_EMOTE");
    if (Object.keys(CHAT_EMOTES).indexOf(giveEmote) > -1) {
        if (!plo.hasEmote(giveEmote, sb, data)) {
            plo.data.emotes.push(giveEmote);
            plo.save(data);
            tellPlayer(pl, "&aUnlocked emote: &r:" + giveEmote + ":!");
        } else {
            tellPlayer(pl, "&cYou already have emote '&r:" + giveEmote + ":&c'!");
        }
    }
}


function damaged(e) {
    e.setCanceled(true);
}